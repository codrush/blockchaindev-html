<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CH:边做饺子边聊区块链]]></title>
    <url>%2Ftalk%2Fdumpling-blockchan.html</url>
    <content type="text"><![CDATA[CH这里先给大家拜年了，祝大家狗年财运亨通，做项目顺风顺水。 和面-擀面皮今天唠唠嗑，不搞太多干货。自2016年开始开发国内开源公链项目Metaverse，2016年我还戏称和小蚁项目（如今NEO）相爱相杀，因为那时候还只有我们两大公链，现在看起来现在，只有“被杀”的份儿。好像今年国内还有个什么“国内三大公链”的称呼，名字我就不一一举了，这和国内top3的高校有5家有异曲同工之妙。套用《食神》里面的台词，“争什么争，还不是掺在一起做撒尿牛丸。” 剁饺子馅老实讲，两年前虎哥在老是和我说数字资产、数字身份的区块链的两大核心，我并不是很理解。现在回想，还是虎哥牛逼，他说的这些概念完美的预测了区块链的发展方向，只不过换了个词，都表达相同的概念，简直就是区块链界的库布里克。但我觉得这两个说法不够直观，还是老外直观，用词叫做“Tokenize”，我第一次听到这个词，发现英语真是太6了，把数字资产这个词表达的惟妙惟肖。这么多区块链项目，什么游戏、教育、版权，最终都归结为经济行为，资产和交易作为经济行为里最为核心的内容，把这两解决了，做什么都行，任何具体的项目都是可以从金融里面长出来的，这个生长的过程就是“Tokenize”。所以我认为谈论“区块链思维”是一个表象，真正表达的含义是利用区块链作为工具，把原来不能或很难流通的资产，方便的流动起来，和ABS很像，但从来没有这种工具如此的方便、安全、低廉。2016年谈区块链的时候，很多人都有种幻觉，叫做“区块链万能”。其实并不是，这个大家应该月发现了。那到底什么能，什么不能？区块链就是记账，和记账相关的，就是能，其实就是Token（不用翻译，我觉得挺好）。和Token最相关的是什么？资产和交易啊！ 包饺子现在业界有两个项目我很喜欢，以太坊ETH 和 EOS。我特喜欢看这两人掐架，嘻嘻。这两个项目分别代表了区块链的两个极端：一个完全的去中心化的技术开放平台，一个近乎中心化的高效技术平台。分别代表了V神和BM对区块链的两种不同理解。实际上这也是分布式系统的两个面，一个去中心化，必然带来一个低效的计算系统；一个偏中心化，所以你要首先相信这个系统的维护者。这个就看你选择什么了，这和赌球差不多，你喜欢和看好哪只球队其实都带一点主观性质。可以认为他们设计的区块链结构是互为相反的，ETH在造了一辆马车并在上面搭了一架加农炮，BM造了一辆动车但是上面啥都还没有。你说加农炮能开炮轰敌人（项目），BM说我跑得快。同时我也认为市场都需要这两种类型的区块链。目前V神头疼ETH网络的吞吐量，BM内心就哈哈笑了。但是V神说有我生态，BM内心只能MMP了。所以大伙儿看V神赶着做2.0提升网络吞吐，BM赶着上线抢生态。 以上无论ETH和EOS，我认为其实都可能有个误区，叫做智能合约。我曾经在元界开发群里说，即使全世界都认为区块链的方向是智能合约，我说不是。我举个栗子🌰，BTC =&gt; 汇编语言ETH/EOS =&gt; C/C++语言那么请问你说区块链的方向是编程语言？听起来是不很奇怪？你要说编程语言，后面还有TypeScript/Rust/Go/Python 更方便的语言呢不是？ 一种编程语言的流行程度背后其实是这门编程语言背后框架的多样性决定的。现在没有人写前端是从0开始撸的，上来要么Vue、React或Angular。就算现代C++，也没有上来就手撸所有代码的，比方我们MVS代码使用了jsoncpp、mongoose、boost。所以在开发中，我通常首选“人生苦短”的python（手动笑cry）。 饺子下锅回归正题，我说智能合约不是区块链的发展方向，又说了语言框架，其实我想表达的是——智能合约标准模板才是真正引领区块链的方向。对，我说的就是ERC20。当大家都在讨论ERC20的时候，知道ERC20是什么吗？ERC —— Ethererum Request For Comments，以太坊意见征求稿。其实就是以太坊自己的RFC（注：RFC是互联网标准的一系列编号的文件，可以说当今互联网是建立在这一系列RFC上的）。所以ERC20 是以太坊上第20号标准文件，全称是 ERC-20 Token Standard。那么有人知道ERC55是什么吗？—— ERC-55 Mixed-case checksum address encoding。是什么我也不知道。 那么思考一个问题，为什么ERC20如此广为人知并且流行，但是ERC55却没有？好的，我们回到最开始，区块链最核心的内容是什么？—— 数字资产（Tokenize)、资产和交易。因为ERC20 干对了区块链的核心内容，而ERC55却只是一个技术命题下的标准。 那么如何再设计一个类似ERC20标准的新智能合约模板呢？不不不，不用再设计，增强ERC20就可以了，这也是V神最近在做的事情。绕了一大圈，我强调了智能合约模板标准是未来区块链的发展方向。那么这套模板标准必须是以太坊上的吗？我看未必，所以有EOS，还有国内公链项目QTUM和NEO。NEO已经发力搞了一个NEP-5代币标准，做标准是打造生态的最直接最有效的方式。 吃饺子不蘸酱那么我大元界为什么没有代币标准呢？损色，谁说没有，我这不正在写呢么: mvs-org/mips我们团队给元界打造了一整套MIP用来支持token内置智能合约标准。目前设计了mip-002，mip-006，后续还会有多个mip形成MIP族，整体命名为 MFT(Metaverse Family Token Standard)，有些内部文档并没有放出，比方我还设计了元界数字身份实时授权模式和永久授权模式下的workflow，这些会由另外一套MIP族，整体命名为MID(Metaverse Identity Standard) ，等整理好一起放出来吧。 最后打个广告，我今年3，4月份将会在极客邦旗下产品《极客时间》直播给大家讲区块链，欢迎大家关注哈。 PS：好久没有聊数字身份了，下篇聊聊元界数字身份~]]></content>
      <categories>
        <category>观点</category>
      </categories>
      <tags>
        <tag>区块链 饺子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元界区块大竞猜(内测,普通用户请勿尝试)]]></title>
    <url>%2Fgame%2Fmvs-block-quiz.html</url>
    <content type="text"><![CDATA[竞猜下一个10的整数倍高度的区块哈希的最后一位是否是数字?是-请押注到地址A: MU93d3PEiVNUhjynXYoTDZK1j6CJRxSLgx否-请押注到地址B: MRQr3uG6BUup2TDknuwL8U6ERnzQsNDFaF 例如:区块高度958210, 958220, 958230, 区块哈希分别是12382450071f44e94be72779b3cbb8ff6917de5e8c67df572cafcc8e9ea4359f67d63fc451a02215318181343770d80e15a04c5d838741b20dc9fc331550a6d066e2afbb7269f666c50d6e37ff16df3bf37cf4bd64f0d33787d2d854287f2987226 那么开奖结果分别是: 否，否，是 中奖概率区块哈希的组成其实是十六进制，所以押注的概率:是 62.5% - 否 37.5% 赔率计算公式A胜： (A+B) 0.98 / AB胜： (A+B) 0.98 / B在元界的区块浏览器上可查询上述地址的余额，即可计算赔率。 开奖与结算每次开奖后3个区块开始发起上一轮结算, MVS上的区块时间约30秒，所以一轮大约5~7分钟，奖金结算控制在3分钟以内。系统抽取佣金2%。 如果本轮有任意一方押注资金为0，则无法开奖，所有奖金注入下一轮进行开奖。]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>区块链 游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链应用的去中心化——一个乌托邦]]></title>
    <url>%2Ftalk%2Fdecentralized-blockchain-applications-are-utopia.html</url>
    <content type="text"><![CDATA[对去中心化的质疑如果你在搜索引擎上搜索“区块链+去中心化”，那么你可以得到超过两百多万条的检索结果，并且当前有众多的区块链人在反反复复提及一个观点——“区块链技术将颠覆现有互联网”。对于以上观点，我提出了质疑。 当在讨论区块链的特性时，我们都不约而同地表示去中心化时区块链的一个核心理念，甚至在评价一个区块链应用时，如果它不满足去中心化的特性，就提出质疑甚至否决。对于以上观点，我不甚认同，我认为区块链的核心价值并不是去中心化，而是易于构建可被监督的区块链应用。 区块链的去中心化特性其实是为了描述在这个系统中，作弊的成本非常高，因此区块链可近乎认为是无需第三方的低成本可信沟通环境。如果我们考虑当下的互联网，如此丰富多彩的互联网应用几乎全部是由中心化的设施所提供的。当普通用户在使用这些应用过程中，如果非要在安全和便利中选择一个，用户通常更愿意选择便利。这也是我们为什么无法完全达成去中心化的原因之一，用户在大多数场合中，应用的去中心化并不是他们考虑的第一因素，而是以解决需求为第一动机。 那么，区块链当下到底解决了多少实际需求呢？似乎并不多。这也是我今天想讨论的——去中心化不应当成为区块链应用的核心评价标准，而应当以能否解决实际需求来作为评价标准。 当然，目前仅这一个标准也还难以界定一个区块链应用到底是好是坏。由于区块链应用往往具有交叉跨界的性质，导致了落地断层，懂区块链的不懂业务，懂业务的不懂区块链，双方还在你来我往互相试探，达到相互契合必定还需要一定的时间。在这个过程中，区块链行业如果过分地强调去中心化这种“政治正确”，是难以同化现有的技术生态的。 应用的中心化举个例子，其实我认为世界上最大的区块链应用（广义的）早已诞生：区块浏览器。在数字货币领域，如何判断一笔交易是否已成功达成？资产是否已成功转移到对方账户？各位的第一反应想必就是查询区块浏览器。要知道，绝大部分区块浏览器都是中心化的，将结构化的区块存储到数据库，然后以互联网服务的形式提供给所有用户，我相信没有哪个普通用户会自己动手代码解析区块然后再得出结论：转账成功！我们一边高喊去中心化，一边心安理得地使用这种中心化应用带来的便利，我认为这是一种“精分思维“。 所以我想说的是，区块链厉害的地方不是去中心化，而是能够提供完美的监督机制，让提供服务的平台也无法作弊，即使它是中心化的应用。 说个大家习以为常的过程：你在某平台提币1000个ETP，如果你因故无法登录平台账户，只需要在区块浏览器上查询自己的地址，即可判断提币是否成功。如果区块浏览器上没有相应的交易记录，你可以理直气壮地找平台理论，而平台绝没有任何狡辩的余地。而对比没有区块链的互联网应用，你则很难获得这样的证据。 如此强的监督过程，还可以极大的扩展，将区块浏览器打造成一个超级Oracle（价值中介），来为用户提供更多种类的强监督服务。当然这也取决于区块链本身能提供什么种类的服务，例如元界提供数字资产登记和流转服务，那么元界区块浏览器可以相应地提供”个人资产Watch服务“，再远一点，结合元界的数字身份还可以提供“个人资产证明“。 不同于大家强调的去中心化，我认为区块链的优势在这里已经发挥的相当到位了，姑且称上述服务为“弱中心化“的。 去中心化与弱中心化在一年前，我在知乎回答中提到过，未来的区块链生态一定是去中心化和弱中心并存的。现在我可以再加强一下观点，弱中心的应用会远远超过去中心的应用。 理由如下： 即使消除了信息壁垒，人与人之间仍旧存在信息不对称和认知不对称的问题。所以信息的流转体系中永远都会存在信息提供者（服务者）和信息消费者（用户）这两种角色。 这是由人类社会结构决定的，妄图消除这两种角色之间的差异是非常难的。所以，只要构建应用，无论是区块链应用还是传统互联网应用，必然是一个团体（或机构）的行为，他们会成为服务者，而个人会在这场信息竞赛中基本落后，处于消费者的角色。那么问题来了，只要这两种角色存在，请问完全去中心化是不是一个伪命题？ 中心化和去中心化可以类比集权和民主的概念，去中心化多半是西方社会特别关心的概念，而在我们社会主义阵营中，通常认为中心化是主流，所以去中心化真的是国内应用场景真正关心的？还只是人云亦云？ 一个热门的互联网平台的诞生，去中心化这种理念其实并不与之相契合，，往往是平台赋予了领域内的用户更强大的创造力，我姑且称之为“赋能“过程。“赋能”过程易用性，可传播性往往占据主导地位，在解决了实际需求之后再来考虑安全问题和性能问题。 易用性上的挑战，完全的去中心化往往意味着系统复杂度的上升。而在我以往的工作经验中，在能满足当下业务需求的情况下，能用单点应用解决的问题，绝不动用复杂的架构设计。所以无论从商业还是工程角度，使用一定的中心化策略，往往会好于完全的去中心化策略。 我认为在区块链领域，如何利用当下区块链的特性构建一个相对平等的机制，让用户和平台能够相互监督，才是比较贴近实际的想法。 基础设施 区块链在未来将会成为互联网的底层基础设施之一，它并不会颠覆当下的互联网，恰恰相反它所带来的“区块链思维”将会成为互联网的补充并迅速侵袭互联网，让所有应用以几乎为零的成本享受数字金融带来的便利。 区块链本身是去中心化的，而在区块链应用层面，中心化的应用必然是主流方式。]]></content>
      <categories>
        <category>观点</category>
      </categories>
      <tags>
        <tag>区块链 去中心化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巴比特采访-区块链的CTO需要思考什么?]]></title>
    <url>%2Finterview%2Fwhat-should-CTO-think-on-blockcain.html</url>
    <content type="text"><![CDATA[技术人员一般做到技术高管层面的时候，最大的职能转变是要从写代码转换到对团队的管理。制定战略然后源源不断地提供新的idea让团队去实施。 陈浩从三方面总结了其作为CTO需要思考的内容： 第一，最核心的是要提高公司的生产力。如何让团队达到最高效和最良好的运转状态，并帮团队解决后顾之忧。 第二，是对技术的开拓。团队在开发进程中遇到的技术难题，CTO并不一定要亲自动手去解决，而是优先考虑是否可以充分利用现有的行业资源去发掘更多的技术人才协助。 第三，要感知行业动态。这不单是局限在区块链行业的动态，还要感知所有技术行业动态。比如说目前比较热门的人工智能和云计算的发展趋势，它们是如何和传统架构结合的，与区块链技术是否有结合的可能。 元界（Metaverse）项目发起于2016年8月，是国内较早一批发起的公链项目，涵盖了数字资产和数字身份，通过构建 2B2C 通用技术平台，将资产数字化。 陈浩现任元界CTO，目前的工作重心是数字身份和BaaS服务。 目前国内真正从事区块链开发的项目并不多，较有影响力的公链项目更是屈指可数。造成这一现状的原因是多方面的，比如区块链处于发展早期，缺乏对区块链有深刻理解的综合性人才等。作为区块链领域的CTO，他们需要思考什么？ CTO的核心工作不是写代码技术人员一般做到技术高管层面的时候，最大的职能转变是要从写代码转换到对团队的管理。制定战略然后源源不断地提供新的idea让团队去实施。 陈浩从三方面总结了其作为CTO需要思考的内容： 第一，最核心的是要提高公司的生产力。如何让团队达到最高效和最良好的运转状态，并帮团队解决后顾之忧。 第二，是对技术的开拓。团队在开发进程中遇到的技术难题，CTO并不一定要亲自动手去解决，而是优先考虑是否可以充分利用现有的行业资源去发掘更多的技术人才协助。 第三，要感知行业动态。这不单是局限在区块链行业的动态，还要感知所有技术行业动态。比如说目前比较热门的人工智能和云计算的发展趋势，它们是如何和传统架构结合的，与区块链技术是否有结合的可能。 BaaS陈浩认为区块链会逐渐沉淀到整个互联网的底层，成为底层基础设施去支撑未来所有互联网的应用。这个沉淀过程就是和如何与传统互联网应用架构融合的过程，比如元界提出的基于公链的区块链即服务BaaS（Blockchain as a Service）概念，就是整合了传统的一系列上下游以及周边生态的企业服务方式。 但是对于BaaS陈浩有不一样的理解。 此BaaS非彼“BaaS” IBM及微软提出的“BaaS”服务是基于自身已有的云平台，将现有的区块链技术框架集成到里面，为开发者和厂商提供平台级的区块链技术服务。实现逻辑是：云服务器提供容器，容器装载区块链，区块链再提供服务。陈浩认为这是经典分布式系统（Raft/Paxos/PBFT）的衍生和强化版本，它们的实现是一个技术过程，而非业务过程，准确的定义应该是区块链技术即服务BTaaS（Blockchain Technology as a Service）。 陈浩对区块链即服务（BaaS）的理解是，利用公有区块链产生的数据，提供基于区块链的搜索查询、交易提交，数据分析等一系列操作服务，该操作服务集合可能是中心化的，也可以是去中心化的。 BaaS和BTaaS的不同在于：BaaS使用者不需要知道区块链技术如何实现，而是关注能够实现哪些业务，是否能够拿来即用。BaaS所能支持的生态远远大于BTaaS所能支持生态；BaaS更接近价值互联网形态的具体形式，BTaaS更接近企业软件解决方案。 “不能还是老盯着区块链用了什么算法、提高多少容量这些技术问题。用户不关心这个，他们关心的是你到底能提供什么服务，这才是最重要的，而不是你的技术多么强大。”陈浩希望区块链创业者能够从对技术的偏执转移到对业务的理解。 元界的BaaS服务将是元界的数字身份的基础。元界的数字身份基于元界生态体系搭建，其识别模块将被内置于协议中，并开发辅助支持它的应用程序。根据元界区块链提供的底层功能，围绕BaaS及钱包来开展数字身份的应用，能够为各行业提供可验证、可授权的基础设施服务。应用场景包括征信、借贷、保险、审计等。 做公链的难点对于一些推出BaaS平台的创业公司，陈浩认为他们是联盟链或者私有链的方案提供商，为传统机构提供基于区块链技术的整套解决方案。联盟链或者私有链对区块链的整个生态补充有一定的正面作用，也相对容易做。但是陈浩更看好公链的发展，尽管做起来并不容易。 陈浩认为公链的难点主要有三：技术、市场以及项目落地。 第一，哪种技术选型是最优的。目前已经出现了POW、Pos、DPos等共识算法，未来还会有哪些共识算法，这些共识算法是否更优，还不得而知。 第二，市场运营。联盟链方案提供商只需要根据客户需求制定切实可行的方案即可。公链项目需要关注更多的方面，最明显的是你需要考虑二级市场的流动性及代币持有者的利益等，这是一个长期且耗费巨大精力的过程。 第三，项目的落地。规模大的公司，自身已经积累了大量的用户，会优先选用联盟链解决方案。中小微公司自身资源优势不明显，缺乏大量的客户及流量资源，会更倾向尝试用公链解决方案。同时让普通用户和企业客户接触区块链、了解区块链能干什么、怎么使用区块链服务等，是个相当漫长的过程。 对于区块链的大规模应用，陈浩认为不要将目光局限在区块链自身技术上，更需要放眼整个区块链圈子之外。虽然前段时间玩客云借助区块链的概念进行包装迅速“走红”争议颇多，但陈浩认为不能因此否认它的正面价值，至少我们看到了区块链爆发的要素：庞大的用户群+合理的价值激励体系。“如果区块链通过一系列轰动性的事件，比如说像人工智能里面标志性的事件AlphaGo及升级版先后打败人类棋手李世石、柯洁等，这一系列事件成为非常热的话题，区块链应用大爆发就非常非常接近了。”在这个时点尚未到来之前，比拼的是区块链创业团队的储备，是否能够熬过不期而遇的寒冬。一旦行业爆发就要像加速器一样，跑得更快更远。]]></content>
      <categories>
        <category>采访</category>
      </categories>
      <tags>
        <tag>采访</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从区块链即服务（BaaS）到价值互联网]]></title>
    <url>%2Fconception%2Ffrom-baas-to-value-internet.html</url>
    <content type="text"><![CDATA[信息互联网：是指现如今庞大复杂的信息互联网，目前信息互联网不具备金融属性，通常需要强势的第三方中介提供可信的金融服务，在信息互联网中，技术与业务可通过架构分层来剥离业务和技术的耦合； 价值互联网：是指通过构建一个自带金融属性的互联网络，该网络中第三方中介系统不再是必需的（可以存在），目前来看通过区块链是去实现价值互联网是可行的；区块链通常自带金融系统，且具有排他特性，如果将该金融系统剥离，那么演变为经典分布式系统； 信息互联网下，业务与技术分离的典型产物就是——云计算； 如今云计算的发展已经渐渐突破这种界限，试图渗透到各个垂直领域提供更好的技术方案，最典型的就是金融云解决方案； 但是无论哪种金融云解决方案，都有可重复实例化的性质，即，A厂购买F方案，B厂也购买F方案，但他们运行起来之后A-F和B-F是完全两个不同的实例，他们之间一般没有直接关系，也许在第三方中介机构（O）上有那么一点联系，比方说银行或证券公司。 所以这种情况下也不能称之为价值互联网。 要达成价值互联网的要求必须是，A-F和B-F可以是同一个实例下的不同子网，他们之间的关联可以是直接的，换句话说，第三方中介O提供的某些服务不再是必需的，比方说支付功能（区块链自带支付系统）； 本文作者：陈浩，元界CTO，Metaverse元界开源项目的创始人之一。元界是一个基于公有区块链技术开发的去中心化平台，致力于提供基于资产登记、数字资产交换、数字身份、价值中介的去中心化服务，创建智能资产价值网络。元界官网：The New Reality Blockchain Project 本文尝试探讨如何将公有区块链与现有互联网应用相结合；这里的区块链即服务仅指公有区块链，有关区块链的分类可参考：区块链(Blockchain)深入介绍 一、信息互联网与价值互联网信息互联网：是指现如今庞大复杂的信息互联网，目前信息互联网不具备金融属性，通常需要强势的第三方中介提供可信的金融服务，在信息互联网中，技术与业务可通过架构分层来剥离业务和技术的耦合； 价值互联网：是指通过构建一个自带金融属性的互联网络，该网络中第三方中介系统不再是必需的（可以存在），目前来看通过区块链是去实现价值互联网是可行的；区块链通常自带金融系统，且具有排他特性，如果将该金融系统剥离，那么演变为经典分布式系统； 信息互联网下，业务与技术分离的典型产物就是——云计算； 如今云计算的发展已经渐渐突破这种界限，试图渗透到各个垂直领域提供更好的技术方案，最典型的就是金融云解决方案； 但是无论哪种金融云解决方案，都有可重复实例化的性质，即，A厂购买F方案，B厂也购买F方案，但他们运行起来之后A-F和B-F是完全两个不同的实例，他们之间一般没有直接关系，也许在第三方中介机构（O）上有那么一点联系，比方说银行或证券公司。 所以这种情况下也不能称之为价值互联网。 要达成价值互联网的要求必须是，A-F和B-F可以是同一个实例下的不同子网，他们之间的关联可以是直接的，换句话说，第三方中介O提供的某些服务不再是必需的，比方说支付功能（区块链自带支付系统）； 二、再谈BaaS与BTaaS区块链即服务（BaaS） —— Blockchain as a Service区块链技术服务（BTaaS） —— Blockchain Technology as a Service这种分类吸取了云计算领域的PaaS/SaaS的概念； 在上图中我将BTaaS放到和PaaS同一个级别，BaaS放到了SaaS同一个级别；如此分类的原因是，它们有一个最大的共同点是面向的用户是相同的。 笔者自去年开始关注BaaS这个概念，也撰写了两篇文尝试在公链和联盟链的格局下明确这个概念：《退化的联盟链与BaaS》，《论联盟链局限性与公有链》 这两篇文主要提出了两个观点： 第一是联盟链的本质不是技术问题，而是业务建模的问题，这种业务建模往往伴随着设计非合作博弈情况下的均衡问题，能否出现一个演化稳定策略满足系统中所有人成为了联盟链的关键，试图完全依赖只具有拜占庭容错机制的系统肯定是行不通的； 第二是区块链作为一种特殊的系统，它本身的金融属性是无法剥离的，正因为它的金融特性才使得系统具有生命力，当剥离了它的金融属性，它就会退化成一个单纯的拜占庭容错系统，它本身所能支持的生态也会被大大削弱； 假设读者赞同以上两个观点，那么我们会有一个结论： BaaS 通常是指公有区块链提供的服务，而BTaaS通常就是指使用联盟链提供的服务。 我们也有如下推论：BaaS所能支持的生态远远大于BTaaS所能支持生态BaaS更接近价值互联网形态的具体形式，BTaaS更接近企业软件解决方案； 笔者这里正好给BaaS和BTaaS下个定义： 区块链即服务（BaaS）是指利用公有区块链产生的数据，提供基于区块链的搜索查询、交易提交，数据分析等一系列操作服务，该操作服务集合可能是中心化的，也可以是去中心化的。目前在区块链领域，区块浏览器、数字货币交易平台以及公链衍生应用：存证型-Factom， 数字身份型-uPort 等都可称之为区块链服务。 区块链技术服务（BTaaS）是指利用区块链技术构建了自己的私有分布式系统，该系统可以认为是经典分布式系统（Raft/Paxos/PBFT）的衍生和强化版本。结合现有云计算技术，可以为开发者和厂商提供平台级的区块链技术服务。 上图中展示了BaaS与BTaaS的区别与应用；到这里，读者可以有个疑问，为什么要区分这么清楚？因为这决定了区块链新业务架构模式的走向； 三、价值互联网（区块链）下的应用创新人们有种误区，认为完全去中心化的DAPP才是未来的方向，实际上这是不现实的； 目前所有的经济系统依赖庞大的银行、证券系统，妄图全部脱离搞自己的经济系统更不现实。 将区块链作为底层金融基础设施，以BaaS的形式提供不可篡改，公开透明的金融服务应用不失为一个可行的方案；区块链是基础设施，代表着用户渠道，区块链应用是B端业务，是服务提供商，它们承当了价值互联网中的主要角色； 金融应用分两种，高频使用和低频使用的： 高频的通常是支付、借贷等功能；低频的通常是撮合交易、期货以及金融衍生品； 我们将高频使用的功能优先沉淀为区块链基础设施，低频使用的功能可以先以中心化应用（BaaS）的形式提供，逐步过渡到区块链。 在这个过程中BaaS会一直扮演着主要角色； 在BaaS下，区块链的商业模式更像是B2B2C的模式，BaaS提供了2B的具体形式，2C则是由区块链本身提供的，因为公链本身就聚集了大量用户； 而作为机构（B端），提供服务必然收费，中心化也是必然选择，我们其实不必妄图完全地去中心化，区块链在这个过程中更像是发挥了拥有强大的证据链的中介作用，一切B端都会被用户所监督； 实际上BaaS模式已经在区块链领域逐步显现：大量的数字货币交易平台（P网、B网），各种区块浏览器（blockchain.info）、tokenmaster都是中心化的，但都依然展现了强大的生命力； 笔者是Metaverse元界开源项目的创始人之一，图3示意了一个公链展现出来的BaaS，元界按照数字资产、数字身份、价值中介三大主要元素来达成BaaS。 BaaS可以是元界上的ZenDao项目（http://zendao.org/），可以是ZenGold项目（http://zengold.org/），可以任何围绕元界作为区块链金融基础设施的项目。所以笔者在公司内部索性划分了一个BaaS开发组 所以任何围绕公链，以BaaS提供服务的应用，都是价值互联网下的应用创新。 四、再谈公链链发展区块链的系统性风险这个问题尤为被大家关心，其实这也是一个接受的过程。 比方很多人诟病PoW挖矿浪费能源不环保，这个问题和电动汽车的问题有点像，属于能源结构的问题，不是PoW本身的问题。 比方说银行金库消耗的材料不也是重工业制造的吗？重工业同样消耗大量能源。 任何公链还面临了一个系统性风险，即拜占庭容错阈值被突破的风险； 其实这个问题算是犯了区块链初学者的毛病，只指看到了技术上的共识，而看不到社区共识，其实在现实社会中，社区共识往往会发挥比技术共识还要大的力量，这种系统性风险往往还是归结到社区共识上，社区共识在某种程度上会监督所有行为。 身份问题这两天有个热门问题《什么样的用户不喜欢微信？》 目前大家还停留在查地址，查交易的阶段，未来的区块链一定是带身份的，而且是用户自己控制自己完全拥有的身份机制，比方说元界的数字身份就是就有非常好的设计来解决大部分互联网身份难题（嗯，虽然我还没发布元界数字身份白皮书，也只能厚着脸皮了，囧逃。。。） 数据隐私这个问题其实可以归结到身份问题底下，但有时候是单纯的数据隐私，未必是身份的，所以我也预感未来会成为一个热门研究方向。 在这个问题下，其实还有一个零知识证明的问题，在区块领域有两个币种（Zcash\ZCoin）t提供了绝佳的支付隐私案例，但是我认为零知识证明的绝佳应用不是支付，而是数字身份； 链下数据导入链上链下数据导入链上的前提是解决数据隐私，其次是身份问题，最后才是应用问题； 这个问题其实会在其他问题慢慢解决后自然解决了，它本身是一个结果，而不会成为区块链的主要技术问题； 产品形态区块链产品的核心竞争力将是围绕核心钱包优化出来的新型应用；BaaS目前将是提供区块链产品的最有竞争力的形式，可以无缝的衔接到互联网应用上；]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>区块链服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈对区块链服务（BaaS）的理解]]></title>
    <url>%2Fconception%2Fconceptions-on-BAAS.html</url>
    <content type="text"><![CDATA[我认为在下半年会一个有关区块链的新词火热起来：BaaS（区块链即服务Blockchain as a Service） 理由有两： 第一、目前区块链的私有链（联盟链）竞争已经进入白热化阶段，HyperLedger/EEA等私有链产品已经摩拳擦掌，国内也有很多类似产品在相互竞争。目前还未进入真正的市场宣传阶段，如果进入对技术型产品的宣传阶段，势必会将BaaS的概念炒热。 第二、BaaS的概念可以很好地与云服务平台相结合，形成将区块链技术框架嵌入云计算平台的结合趋势。 我认为上述趋势和做法，完全偏离了的区块链发展方向。我会详细说明以下几点以证明我的观点： 什么是区块链服务？ 什么是区块链技术服务？ 两者区别。 为什么说区块链服务比区块链技术服务重要？ 如何构建区块链服务？ 我认为在下半年会一个有关区块链的新词火热起来：BaaS（区块链即服务Blockchain as a Service） 理由有两： 第一、目前区块链的私有链（联盟链）竞争已经进入白热化阶段，HyperLedger/EEA等私有链产品已经摩拳擦掌，国内也有很多类似产品在相互竞争。目前还未进入真正的市场宣传阶段，如果进入对技术型产品的宣传阶段，势必会将BaaS的概念炒热。 第二、BaaS的概念可以很好地与云服务平台相结合，形成将区块链技术框架嵌入云计算平台的结合趋势。 我认为上述趋势和做法，完全偏离了的区块链发展方向。我会详细说明以下几点以证明我的观点： 什么是区块链服务？ 什么是区块链技术服务？ 两者区别。 为什么说区块链服务比区块链技术服务重要？ 如何构建区块链服务？ 1. 什么是区块链服务？区块链服务是指利用区块链产生的数据，提供基于区块链的搜索查询、任务提交，等一系列操作服务。 目前在区块链领域，只有各大公链的区块浏览器能称之为区块链服务，以及部分公链衍生应用：存证型-Factom，数字身份型-uPort等。 这些应用都有个特点，基于已存在的公链，发挥并强化公链已有的功能，让公链为大家提供更好的区块链服务。 也就是说，如果要开发一个区块链服务型应用，我们一般指在公链上开发一个应用。 2. 什么是区块链技术服务？区块链技术服务是指利用区块链技术，去构建一个新的区块链，去替代传统互联网架构的服务。 目前在区块链领域，主要是HyperLedger，multichain，以太坊私有链等多个框架去构建多个实例，去解决已经被证明使用传统互联网技术能很好解决的问题，我一般称“强行区块链”。 这些应用也有典型特点，希望构建属于自己的区块链系统，其实称之为分布式账本技术更合适些。 在这种情况下，我更推荐一个更好的技术栈：pingcap/tidb，或者是基于PBFT协议的分布式数据库，而不是私有区块链系统。 所以我把区块链技术服务称之为 BaTS。 3. 两者区别。两者区别在于 BaTS 专注的是技术过程，而不是产品过程，而BaaS恰恰相反，而且通常指公链服务。 举个类比例子，阿里云不是一个卖云计算技术的公司，而是一个卖云计算实例的公司。阿里云不会告诉客户如何搭建一个自己的云服务平台，而是阿里云直接构建好一堆拿来即用的实例，用户只需要为实例付费即可。 同理，BaaS应当会用户提供基于比特币/以太坊等公链的实例服务，而不是提供如何再构建区块链系统的服务。 这其实是由区块链的特性决定的，去中心化、不可篡改、公开透明等优点只有在公链才能无限放大，而在联盟链私有链的情况下迅速的退化成非合作博弈的均衡问题，已不再是技术问题了，与是不是区块链技术无关。详细见我的文章：论联盟链局限性与公有链 | blockchaindev.org 4. 为什么说区块链服务比区块链技术服务重要？再重新设计一个HTTP协议更重要，还是利用HTTP去构建互联网应用更重要？ 虽然目前比特币，以太坊，元界等公链有诸多缺陷，但是开发者不如集中精力，去解决BIP，EIP，MIP，让已经稳定的公链系统生态更加完善。（智能合约开发者并不能算作区块链开发者，算区块链应用开发者） 比特币区块链目前能够提供稳定开放的互联网数字货币服务，也有很多研发团队正在改善比特币区块链生态，如RSK（RootStock）将使比特币区块链支持智能合约，这无疑会给公链生态带来较大的促进作用。这是为了提供更好的区块链服务而改善现有区块链技术栈的绝佳案例。 5. 如何构建区块链服务？区块链服务是指根据公链提供的基础设施开发公链应用，并运行应用提供服务。 如在以太坊上使用智能合约开发公链应用，并在以太坊节点上运行对公众提供有效服务。在比特币上，利用比特币有限的功能，提供一些存证服务。 区块链开发者应当建立有效的渠道，能够收集当前区块链的不足，并进行针对性的改进，这种过程我们称之为Improvement Proposals （改进提案）：比特币隔离见证（由一系列BIP组成）就是一个很好的例子。 应用层的开发者利用IP过程可以将在使用过程中发现的问题反馈给开发者，形成一个良性循环。 且IP过程不应当仅限在技术领域，而应当深入Business Layer。 6. 对公链基础技术设施的一个预测。全球绝大部分国家支持比特币支付，但仍有大量的商家并不懂如何搭建比特币服务端钱包，需要花费大量的力气研究公链钱包部署甚至优化，但是他们甚至没有足够的技术人员来部署配置。另外一方面，比特币/以太坊/元界的官方版钱包的LevelDB对服务端其实很不友好，根本不适合服务端应用。 大的技术平台应当着力优化各种钱包，将其变成服务端稳定可扩展的版本，绝对比提供区块链技术栈要有用得多。 希望不久将来就会有云计算平台（虽然我都和微软Azure/阿里巴巴阿里云表达过需求）提供比特币/以太坊/元界等公链的全节点服务，用户只需要付费即可使用。 未来公链的下一个发展方向肯定是轻钱包（移动端）技术，离线支付技术，公链应用开发，云计算平台提供简单易用的公链全节点实例服务，每个普通人都可以购买的专属全节点服务，利用轻支付/离线支付等手段，将主公私钥对分离，轻钱包端提供交易签名，全节点只负责验证并发送交易，这样才可以做到完美的用户级的产品。]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>区块链服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用区块链技术进行项目开发]]></title>
    <url>%2Farchives%2F13-development-in-blockchain.html</url>
    <content type="text"><![CDATA[区块链是目前一个比较热门的新概念，蕴含了技术与金融两层概念。从技术角度来看，这是一个牺牲一致性效率且保证最终一致性的的分布式的数据库，当然这是比较片面的。从经济学的角度来看，这种容错能力很强的点对点网络，恰恰满足了共享经济的一个必须要求——低成本的可信环境。 本文以联盟链为例，描述了实践一个联盟链的基本过程，包含以下内容： 业务场景的构建与初步分析,业务场景建模,开发路径,开发难点。本文无法涵盖所有类型的开发，主要提供一些开发思路，并附带说明一下可行的做法。 区块链是目前一个比较热门的新概念，蕴含了技术与金融两层概念。从技术角度来看，这是一个牺牲一致性效率且保证最终一致性的的分布式的数据库，当然这是比较片面的。从经济学的角度来看，这种容错能力很强的点对点网络，恰恰满足了共享经济的一个必须要求——低成本的可信环境。 本文以联盟链为例，描述了实践一个联盟链的基本过程，包含以下内容： 业务场景的构建与初步分析,业务场景建模,开发路径,开发难点。本文无法涵盖所有类型的开发，主要提供一些开发思路，并附带说明一下可行的做法。 一、 总体思路首先要确定做个区块链的类型，是公证型区块链还是价值型？ 公证型区块链：是指仅限一些关键数据自证、披露、防篡改等功能的区块链，通常是在价值型区块链中附带的功能，也可以单独扩展，用于公示公开等。价值型区块链：是指可以进行资产所有权转移的一种记账账本。 在价值型区块链上，我们需要确定目标区块链的总体定位：到底是一个普适的价值传输区块链，还是特定场景下的区块链？如果是特定场景下的区块链，我们通常推荐超级账本作为技术原型，如果是比较通用的价值区块链，我们推荐以太坊的思路。 二、 业务场景的构建与初步分析首先要明确的观点是，区块链不是万能的。很多场景其实是不需要区块链技术也能解决的。 在跨境支付领域，区块链能很好的发挥是因为存在很多点对点的跨境机构有大量的支付清算需求，而又不希望中间机构参与的话，区块链是很好的选择。 但是在一些集团内部，大型公司内部，区块链解决方案基本上远远不如传统的企业资源解决方案的。 1. 需求痛点分析一般需求痛点在满足以下条件的时候，可以考虑使用区块链： 存在一个不信任的P2P网络环境节点之间是对等节点，不存在一个绝对仲裁者。节点之间的行为是博弈行为。P2P网络可能包含输入和输出，当包含输入和输出时，区块链不再封闭。 对于某个节点一般有以下几种行为（包括但不限于）： 不信任其他节点；保证自己的收益最大化；自私获取但不贡献资源。针对以上情景的业务建模，需要针对具体的业务逻辑结合博弈论推导出满足自己需求的方案即可。 案例1： 通常我们有不同的机构A，B，C，存在不对称的信息交换需求，即A，B，C分别具有部分数据，但三者组合到一起具有市场的全量数据。 但是作为A，想知道B，C是否拥有自己数据集合中的某个点数据，根据这个结果来调整自己的购买策略。 案例2： 我们有不同的机构X，Y，Z，存在信息反馈的需求，当Z收到Y的服务时，会给Y一个信息反馈，这种反馈可能是信用评价，也可能只是响应反馈。总之这种反馈需要记录在案，X会根据Z的信息反馈结果调整自己的购买策略。当X购买服务时，同样会给Y一个反馈，Z也会收到反馈。 2. 非区块链技术能否解决以上两个案例首先考虑使用非区块链是否可以解决： 针对案例1，敏感数据和私有数据是不会公开的，即使加密也不会被允许上传到区块链。所以产生了一个数据输入输出区块链的过程，该过程是区块链不可控制的。 那么使用传统的技术是否可以控制呢？貌似也不行，能够满足不暴露敏感数据的方案也只有HASH计算和同态加密。 但是这两者都要求数据传输到指定位置。 通常我们会考虑使用零知识证明作为解决方案，然而具体的算法可能需要根据具体业务逻辑进行构建，结合简单智能合约，根据查询结果产生不同输出。 针对案例2，反馈信息的容易篡改性，可刷单等问题是最大的，如何保证这种信息反馈是客观中立不可篡改的，可以结合区块链代币的币龄使交易具有方向性来防止作弊行为。 三、业务场景建模针对第二节中的两个案例，我们接下来要进行建模，除去核心痛点，我们必然还有记账的需求，本质上任何案例中每个节点都既是服务方，也是客户方，那么怎么衡量自己贡献和索取了多少呢？所以任何区块链平台上，必须是要有代币系统的，否则记账将非常困难在业务场景建模过程中，我们主要关注如何使节点之间达成帕累托改进，而不是因为每个节点是自私行为，让区块链服务名存实亡。 四、 开发路径1. 区块链原型选取根据本文开头的叙述，如果是特定场景的区块链解决方案，建议Hyperledger fabric，当然搭建以太坊私有链也是可以的。 下图是一些以太坊和fabric的比较： 以太坊与HyperLedger相同点： 都是提供区块链业务实现的平台，业务实现都是通过智能合约来完成，以达到最大的灵活性和对底层的不修改。以太坊是：EVM虚拟机，Solidity合约语言HyperLedger是: Shim链码容器, 用GO编写合约。官方版本都使用GO语言实现因为都是提供第三方可编程能力，由于难度大，内部难免存在漏洞。对外则存在恶意程序攻击的威胁。尤其是在做为公有链时，威胁将会更大。上个月以太坊已有报合约solidity语言漏洞 以太坊与HyperLedger不同点： 以太坊只提供智能合约能力。也恰好吻合他的定位：智能合约和去中心化应用平台。对系统安全性或准入机制无底层无核心上的支持。而HyperLedger，在吸收以太坊智能合约特点的同时，提供MemberShip及身份验证角色管理等模块。更贴近商业应用场景。共识机制不同。由于共识的不一样，所以每秒可处理的交易量也不一样，以太坊是每秒千级别的处理量。而HyperLedger可以达到十万级别的处理量。采用的技术实现思路上不一样。以太坊更多的是靠自己实现，自己照轮子，有点开发人员炫技的感觉，如自己提供合约语言solidity, 自己实现EVM(这个可能是实际需要) 下图是笔者曾经的一个私链项目中对两者的比较（私链考虑了Hydrachain的可行性）： 当然，如果考虑自行开发，建议搭建基础比特币网络，做加法，更改以下： 共识算法网络传送协议附加合约（可选）其实智能合约在一些场景中不是必选项，对于用户来说，可靠方便实时是第一需求，如果针对特定的应用场景，将“合约”固化在区块链里面，也是一种可行的思路。 针对以上两种联盟链实现，笔者还想强调的是，并不是所有服务一定得是区块链的，笔者构想了一个通用的保护伞型结构， 如比特币的侧链技术，主链提供基础账本服务，侧链提供特定场景服务，侧链上的应用可以是非区块链实现的，只需接口注册即可。 3.交互接口设计在交互接口设计上，推荐使用目前业界通用的Json-RPC接口，扩展性和友好性兼备。一般我们将接口分为两类：开放接口和账户接口。开放接口是指区块链本身的描述信息，是不需要认证的。而账户接口是需要账户认证的。 4. 基础账本设计包含以下几个问题：原型区块链是否已经满足需求？如果针对以太坊，基本上是不需要改动基础账本的，只需构建智能合约即可。如何以比特币体系为基础，则可能有较大的改动。 不满足需求如何改动基础账本？这个其实要视账户模型而定，如果使用UTXO模式时，改动重点在如何嵌入模板交易体。如果使用Balance模式，那么则没有这个问题。 5. 业务扩展层设计包含以下几个问题：扩展层是外接区块链还是内置到区块链？如果包含数据输入，是否需要脱敏？脱敏后如何上链？ 五、开发转变和开发难点1. 开发思维的转变与传统网络服务不同的是：区块链开发不再以面向服务为主要关注点，而是面向账本和交易。 开发者面对的不再是以高可用高并发的应用程序为主要指标，而是切换到了面向用户的，关注用户友好性和开发扩展性的终端程序开发。 所以高并发高性能不再是区块链终端的核心指标，安全性，可扩展性，友好性成了主要指标。 下图是笔者在中国技术开放日上提到的一个工作流程： 仅适用（联盟链/私有链）项目。 2. 开发难点开发难点有三： 目前开发人力资源储备不足目前比较成熟的技术体系有：比特币及衍生技术体系，以太坊，超级账本HyperLedger fabric，比特股Bitshares，瑞波Ripple，未来币NXT。 其中列出的前三个项目是最有影响力的区块链项目。比特币以及衍生技术多以C++语言进行开发；以太坊支持大部分主流语言，官方以Golang为主，也有其他分支的项目如Rust语言的Parity钱包；超级账本目前以Golang为主。 从目前上海地区的区块链从业人员来看，保守估计在400~500左右。按一半的开发人员计算，也才200多个，面对巨大的市场需求，人才是极度稀缺的。 由于C++目前仅在金融和游戏领域有部分需求，所以C++工程师不多，尤其是高水平的C++工程师就更少了。Go作为新兴语言，发展势头很猛，但是Go的生态也不如JAVA大。 如果从JAVA的角度看，如何把JAVA的生态利用起来，目前区块链还没有做到那个地步。 综合来看，区块链在技术方面与其他技术的结合还有待探索。 区块链是交叉学科，需要各方面工程实践的经验在实践方面，我们希望区块链从业人员同时了解技术和金融业务，这个要求比较高。 对各个区块链技术体系理解的偏差，区块链技术和概念日新月异，闭门开发可能会走到死胡同，如何保持一部分精力更新知识体系，同时保证开发进度对开发人员是有较大挑战的。区块链作为一门新兴的技术，涵盖了去中心化，去信任，共享经济，分布式计算，分布式存储等多方面的内容，考验着技术人员的学习能力和思考能力。在未来，区块链将同人工智能一起，会影响到普通人生活的方方面面。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InfoQ中国技术开放日-上海站-链上金融]]></title>
    <url>%2Farchives%2F12-infoq-tech-shares.html</url>
    <content type="text"><![CDATA[笔者荣幸参加了2017年年底中国技术开放日上海站的演讲，2016年12月17日，由极客邦科技、XNode联合主办，上海市静安区科学技术委员会光临指导的“中国技术开放日上海站之FinTech专场——技术重定金融，未来大有不同”在静安区800秀创意园圆满召开。FinTech所带来的机遇和挑战、区块链、大数据、人工智能、云计算、智能投顾等6大主题演讲分别讲述了重要的FinTech发展趋势，分享了目前行业里领先的实践经验。视频地址 笔者荣幸参加了2017年年底中国技术开放日上海站的演讲，2016年12月17日，由极客邦科技、XNode联合主办，上海市静安区科学技术委员会光临指导的“中国技术开放日上海站之FinTech专场——技术重定金融，未来大有不同”在静安区800秀创意园圆满召开。FinTech所带来的机遇和挑战、区块链、大数据、人工智能、云计算、智能投顾等6大主题演讲分别讲述了重要的FinTech发展趋势，分享了目前行业里领先的实践经验。视频地址 此次演讲包括：（1）区块链技术的演化、关于联盟区块链相关问题解读；（2）公链的图谱和生态、区块链的一些主要指标、区块链与传统架构的不同点；（3）公有区块链的架构与选型、区块链开发中的实践；（4）如何将我们设计的公有链转化为联盟链等四部分内容，分享了维优区块链的公有区块链技术实践。 演讲PPT下载：中国技术开放日-上海站-陈浩-链上金融-1213.pdf]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Paxos到拜占庭容错，兼谈区块链的共识协议]]></title>
    <url>%2Farchives%2F10-from-Paxos-to-PBFT.html</url>
    <content type="text"><![CDATA[这是一篇转载文章，原文地址，原文作者data-geek已授权转载。本文建立在在很多论文的基础上，概括得非常好，比我的《浅谈区块链共识机制与分布式一致性算法》更深度。 高可用架构在分布式系统设计中是最核心的挑战之一，拜占庭容错则是解决高效容错问题的通用方案。拜占庭系统来源于拜占庭将军问题，在古代，一些拜占庭的将军率领他们的部队要攻占敌人的一个城池, 每个将军只能控制他们自己的部队并且通过信使传递消息给其他的将军(这条消息只有参与的两个将军知道，其他的将军可以打听，但是不能验证消息的正确性)。如果这些将军中有些是来自敌方的奸细，那么如何使忠诚的将军仍然可以达成行动协议而不受奸细的挑拨，就是拜占庭将军问题。分布式系统的每一个节点可以类比成将军，服务器之间的消息传递可以类比成信使，服务器可能会发生错误而产生错误的信息传达给其他服务器。因此拜占庭容错系统是指：在一个拥有n台服务器的系统中，整个系统对于每一个请求需满足以下两个条件： 所有非拜占庭服务器使用相同的输入信息，产生一致的结果；如果输入的信息正确，那么所有非拜占庭服务器必须接受这个信息，并计算相应的结果。其中，发生故障的服务器称为拜占庭服务器。这两个条件被称为共识Consensus，它是分布式系统容错处理的最基础问题。在拜占庭系统的实际运行过程中，一般假设整个系统的拜占庭服务器不超过f台，并且每个请求还需要满足同时两个指标： safety：任何已经完成的请求都不会被更改,它可以被之后请求看到; liveness：可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。 这是一篇转载文章，原文地址，原文作者data-geek已授权转载。本文建立在在很多论文的基础上，概括得非常好，比我的《浅谈区块链共识机制与分布式一致性算法》更深度。 高可用架构在分布式系统设计中是最核心的挑战之一，拜占庭容错则是解决高效容错问题的通用方案。拜占庭系统来源于拜占庭将军问题，在古代，一些拜占庭的将军率领他们的部队要攻占敌人的一个城池, 每个将军只能控制他们自己的部队并且通过信使传递消息给其他的将军(这条消息只有参与的两个将军知道，其他的将军可以打听，但是不能验证消息的正确性)。如果这些将军中有些是来自敌方的奸细，那么如何使忠诚的将军仍然可以达成行动协议而不受奸细的挑拨，就是拜占庭将军问题。分布式系统的每一个节点可以类比成将军，服务器之间的消息传递可以类比成信使，服务器可能会发生错误而产生错误的信息传达给其他服务器。因此拜占庭容错系统是指：在一个拥有n台服务器的系统中，整个系统对于每一个请求需满足以下两个条件： 所有非拜占庭服务器使用相同的输入信息，产生一致的结果；如果输入的信息正确，那么所有非拜占庭服务器必须接受这个信息，并计算相应的结果。其中，发生故障的服务器称为拜占庭服务器。这两个条件被称为共识Consensus，它是分布式系统容错处理的最基础问题。在拜占庭系统的实际运行过程中，一般假设整个系统的拜占庭服务器不超过f台，并且每个请求还需要满足同时两个指标： safety：任何已经完成的请求都不会被更改,它可以被之后请求看到; liveness：可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。 在实际网络中，拜占庭系统需要指数级的算法才能解决，随着大规模分布式系统尤其是云计算的兴起，通过放松liveness来提高性能的简化拜占庭协议也不断涌现并在具体系统中得到运用，例如PBFT ，Paxos，Raft等等。从目前研究现状来看，拜占庭系统的设计主要分为状态机拜占庭协议和Quorum拜占庭协议。两种协议在功能上的主要区别在于：前者需要给所有的请求安排序号，所有请求必须按顺序执行，主要用于对于系统状态敏感的分布式计算系统中；后者不需要为请求安排序号，多个请求可以同时执行，主要被应用于分布式存储系统中。拜占庭容错技术的研究方向主要是降低系统开销,缩小与目前实际应用中的系统之间的差距。 状态机拜占庭系统的特点是整个系统共同维护一个状态，所有服务器采取一致的行动，包含三种协议：一致性协议agreement，检查点协议checkpoint，视图更换协议view change。 一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。一般有一个节点作为主节点，负责将客户端的请求排序，其余是从节点，按照主节点提供的顺序执行请求。所有的服务器在相同的配置信息下工作，这个配置信息称为view，每更换一次主节点，view随之发生变化。一致性协议包含至少三个阶段，发送请求request，序号分配pre-prepare，和返回结果reply。根据协议设计不同，还可能会包含交互prepare，序号确认commit等阶段。 拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以,不同服务器状态可能不一致。周期性的检查点协议可以定期地处理日志，及时纠正服务器状态。 一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。 Castro和Liskov[4]早先提出了Practical Byzantine Fault Tolerance(PBFT)，首次将拜占庭协议的复杂度从指数级降低到多项式级别，使拜占庭协议在分布式系统中应用成为可能。这个算法可以在异步网络中不保证liveness的情况下解决拜占庭容错问题。 虽然不保证Liveness，但是这个算法进入无限循环的概率非常低，在工程中是完全可用的。为此Barbara Liskov获得了2008年代图灵奖。PBFT采取两个假设提供状态复制： 系统中只有一小部分数目可能是拜占庭服务器 系统依赖占据主导的选举来达成共识，确保结果正确 如果系统中有3f+1个节点，那么PBFT可以容忍拜占庭服务器不超过f个。简单解释一下原因：假设有三个将军, 只有一个叛徒。如果A是叛徒，那么A可能会给B发出进攻，然后给C发出撤退的命令。当B和C互相同步信息的时候他们会发现两个不一致的信息。但是B和C谁也无法判断谁是叛徒，比如从B的角度来看，他无法判断A是叛徒或者C是叛徒。所以三个将军里有一个叛徒是无法解决的。为了确保正确，PBFT两两交互确定交集后才能确定一个非叛徒：因此由-(N-f)＋(N-f)-N&gt;=f+1推导出N&gt;=3f+1。 PBFT的一致性协议如下图所示，每一个客户端的请求需要5个阶段才能完成。PBFT通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求，由于客户端不能从服务器端获得任何服务器运行状态的信息，因此PBFT 协议中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。 PBFT采取的设计思路是将所有的工作都放在服务器端进行，例如达成一致性，监测拜占庭主节点等。因此，它的一致性协议设计较复杂，其中有两个阶段需要服务器之间的两两交互，数据处理量大，计算复杂。 PBFT在很多场景都有应用，例如Liskov曾经把它用于一种NFS的实现，最近一个热门的应用是在IBM主导的区块链超级账本项目中，除了PBFT之外，超级账本项目还引入了基于PBFT的自用共识协议Sieve[5]，它的目的是希望在PBFT基础之上能够对节点的输出也做好共识，这是因为超级账本项目的一个重要功能是提供区块链之上的智能合约——就是在区块链上执行的一段代码，因此它会带来区块链账本上最终状态的不确定，为此Sieve会在PBFT实现的基础之上引入代码执行结果签名进行验证。 状态机拜占庭系统同一时刻只能执行一个请求，因此服务器之间执行请求顺序要求完全一致。而在许多分布式存储系统中，应用通常不要求严格的执行顺序，但对响应时间很敏感，因此人们提出Quorum拜占庭系统。Quorum系统是指共享数据存储在一组服务器上，通过访问服务器的一个大小恒定的子集(quorum)来提供读/写操作。这类协议都含有一个特性：规定访问的子集大小后，任何一个这样的子集都包含最新的数据，并且一定可以读出来。Quorum 拜占庭系统则是在此基础上保证在服务器出现拜占庭错误时，系统的一致性语义仍然成立。这一类系统写操作过程是：首先，客户端c从某一个大小恒定的服务器子集Q中读取时间戳A，客户端c从可用时间戳t中选取大于任何一个A 中的时间戳并且大于所有c使用过的时间戳；然后，客户端c发送(v,t)给所有服务器(v为需更新数据，t为时间戳)，直到收到某一个大小恒定的服务器子集的反馈信息。这一类系统读操作过程是：客户端c获得某一个恒定大小的服务器子集Q中所有服务器返回的最新数据信息；然后，c按照具体协议要求从中选取需要的数值。 把拜占庭容错系统的场景放松，不允许系统中出现叛徒（也就是说没有黑客攻击，不会出现伪造消息等情况），这样对于数据中心分布式系统构建是普遍情况。Paxos是第一个适用于这种系统的共识算法，但不适用于拜占庭容错系统（Byzanetine Paxos除外）。Paxos运行在称为副本的一组进程集合，这些进程需要在即使发生错误的情况下也能在某一个值上达成一致，如果半数以上的副本在足够长的时间内没有发生crash，那么所有运行中的副本将可以在某个提出的value上达成一致：在状态机复制中，这意味着需要在“(多副本)日志中的下一条记录是哪条”上达成一致。 借用吴镝的图说明下Paxos过程：Paxos分为Prepare和Accept两个阶段。协议中有两个主要的角色，Proposer和Acceptor。value被大多数接受之前，每个Acceptor可以accept多个不同的值。但是，一旦一个value被majority accept(即value达成一致)，那么这个value就不会变了。因为Prepare阶段会将该value给找出来，随后Accept阶段会使用这个value，后续的所有的提案都会选择这个value。 需要注意的是，每个阶段都是收到majority的响应后即开始处理。并且由于机器会宕机，Acceptor需要对acceptedProposalID，acceptedValue和minProposal进行持久化。 从流程中可以看出Prepare有两个作用: 大的proposal id会block未完成的小的proposal id达成一致的过程，所以为了减少无效的Prepare请求，每次都选择比自己以往见过的proposal id更大的id。 2. 一旦某个value达成一致，那么后续的Prepare都会找到这个value作为accept阶段的值可以看出，一次Paxos达成一致至少需要两次网络交互。 （作者：吴镝 链接：https://zhuanlan.zhihu.com/p/20872811 ） Paxos并不适合于拜占庭容错系统，例如下图中，N2服务器伪造数据，就会让Paxos系统无法达成共识。 Zab(ZooKeeper采用的协议)是一个Paxos变种协议，它名字中的AB是原子多播的意思，因为Zab能够让系统里每个节点按照同样顺序执行同样操作。原子多播和一致性选举被认为是等价问题[3]。Raft是近几年出现的一致性选举协议，在完成Paxos等价的正确性和性能的基础上更加容易理解。从上图可以看到，Zab和Raft都有一个专门步骤用于选举出一个Primary Leader，两者均把要解决的一致性问题分解为一系列独立的子问题：Leader选举，日志复制，以及安全和其他活动。Leader的变化，在Zab和Raft中分别由epoch和term表示，每次Leader选举都会增加epoch或者term的值，因此所有的节点只接受epoch或者term值高的Leader节点，在Leader选举之后，由Leader提议所有副本按照统一顺序进行操作。 在所有Paxos类协议中，每个值(就是提案)实质上就是一条日志记录，记录由两部分标记，在Paxos中叫做slot和ballot，在Zab中叫epoch和counter，在Raft中叫term和index。当Leader针对当前日志广播提案时，跟随者依据法定多数(Quorum)选举，并且在Leader提交后在本地应用该提案。所有的Paxos类协议都是保障全局顺序的。 上面讲述了这些Paxos类协议的相似之处，那么它们在设计上也有一些差别。首先是Leader选举，Zab和Raft都把执行分作阶段来进行(epoch或term)，而Paxos没有。每个epoch都从一次新的选举开始，接下来是广播，然后以Leader失败作为结束。在Zab和Raft中，任何时刻至多只能有一个Leader，而Paxos则没有如此要求，因为Paxos并没有独立的Leader选举阶段，因此Paxos系统会存在多个Leader，然而它仍然可以保证正确，这是由ballot的数字以及Quorum决定的。Zab协议中有三个阶段，每个节点在任何时刻都处于这三个阶段中的某一个。发现阶段就是Leader选举；随后是同步阶段，跟随者按照新Leader自上一次epoch以来所有的日志进行同步；最后是广播阶段，也就是上图中的正常工作模式(normal operation)，Leader持续提交客户决议直至它失效。在Raft中，没有明显的同步阶段，Leader在正常工作模式下跟每个跟随者保持同步，这通过比较每条日志的index和term来做到。因此，Raft的状态更为简单一些。 其次的差别在于副本之间的通信机制。Zab采用消息模型，每次更新都需要至少三个消息：提议，确认，和提交，如上图所示，而Raft则依赖RPC。 Paxos系统在构建分布式系统有一些典型应用场景：首先最容易想到的是Server复制，利用状态机复制可以同步多个Server之间的状态。其次是元数据复制，由于Paxos系统通常不能操作大量数据，因此一些元数据复制会基于Paxos来进行，比如Apache BookKeeper系统和Kafka。第三种是同步服务，例如各种分布式锁。第四种叫拦阻器编排，例如在分布式图处理框架中，基于BSP的模型需要大量拦阻器来进行同步，这通常也由Paxos系统进行，例如Apache Giraph和Hama，以及Google Pregel等。 无论是Paxos还是Raft算法，理论上都可能会进入无法表决通过的死循环(尽管这个概率其实是非常非常低的)，但是他们都是满足safety的，只是放松了liveness的要求, PBFT也是这样。 通常的基础架构中，掌握Paxos协议就已经能够应对所有的高可用设计挑战，然而随着比特币和区块链的热门，Paxos应用的环境就逐渐不再适合，因为随着去中心化网络的引入，分布式系统不再全是可以相信的，因此对于共识算法的需求更加多样，共识算法可以说是区块链为数不多的核心技术之一。目前，区块链应用分为三类： 私有链：这是指在企业内部部署的区块链应用，所有节点都是可以信任的； 联盟链：半封闭生态的交易网络，存在不对等信任的节点； 公有链：开放生态的交易网络，为联盟链和私有链等提供全球交易网络。 由于私有链是封闭生态的存储系统，因此采用Paxos类系统可以达到最优的性能；联盟链有半公开半开放特性，因此拜占庭容错是适合选择之一，例如IBM超级账本项目；对于公有链来说，这种共识算法的要求已经超出了普通分布式系统构建的范畴，再加上交易的特性，因此需要引入更多的安全考虑。 例如比特币采用的工作量证明PoW，就是第一种适用于公有链的共识算法。公有区块链中，参与到系统中的每个节点都是中心，都存放一份完整的交易账本系统。然而，每个节点却不能同时记账，因为节点所处的环境不同，接收到的信息自然不同，如果同时记账的话，必然会导致账本的不一致，造成混乱。既然节点不能同时记账，那就不得不选择哪个节点拥有记账的权力。但是，如果指定某些特殊节点拥有记账的权力，势必又会与去中心化的初衷相违背。比特币区块链通过竞争记账的方式解决了去中心化的记账系统的一致性问题。所谓竞争记账，就是以每个节点的计算能力即“算力”来竞争记账权的一种机制。在比特币系统中，大约每十分钟进行一轮算力竞赛（算力大小会决定赢得一轮竞争的概率，算力高的节点赢得算力竞争的概率更大），竞赛的胜利者，就获得一次记账的权力，这样，一定时间内，只有竞争的胜利者才能记账并向其他节点同步新增账本信息，这就是工作量证明。除了工作量证明之外，还有一些其它的共识算法，主要是解决PoW浪费计算资源，以及吞吐量低下的缺点。例如PoS股权证明机制，基本概念是产生区块的难度应该与在网络里所占的股权(所有权占比)成比例；去中心化股权证明机制DPoS，每个股东可以将其投票权授予一名代表，获票数最多的前100位代表按既定时间表轮流产生区块。 因此，设计区块链，需要在吞吐量，安全等方面做出适合自己的trade off，来选择恰当的共识算法。从区块链的角度来说，Paxos和PoW可以说是trade off的两个极端[6]，而着力于通用区块链的超级账本选取了PBFT也就不难理解了。 [1] Paxos made live: an engineering perspective, Tushar Chandra, Robert Griesemer and Joshua Redstone, ACM Symposium on Principles of Distributed Computing, 2007[2] Consensus in the Cloud: Paxos Systems Demystified, Ailidani Ailijiang, Aleksey Charapko† and Murat Demirbas, Technical Report 2016[3] Unreliable failure detectors for reliable distributed systems, T. Chandra and S. Toueg, Journal of the ACM, vol. 43, no. 2, 1996.[4] Practical Byzantine fault tolerance and proactive recovery, Castro, Miguel and Liskov, Barbara, ACM Transactions on Computer Systems (TOCS), 2002[5] Non-determinism in Byzantine Fault-Tolerant Replication, Cachin, Christian and Schubert, Simon and Vukoli’c, Marko, arXiv preprint arXiv:1603.0735, 2016[6] On scaling decentralized blockchains, Croman, Kyle and Decker, Christian and Eyal, Ittay and Gencer, Adem Efe and Juels, Ari and Kosba, Ahmed and Miller, Andrew and Saxena, Prateek and Shi, Elaine and G”un, Emin, Proc. 3rd Workshop on Bitcoin and Blockchain Research, 2016]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关比特币Core源码CDataStream类的有趣问题]]></title>
    <url>%2Farchives%2F09-bitcoin-serialize-class-CDataStream.html</url>
    <content type="text"><![CDATA[在阅读比特币源码过程中发现了一个有趣的问题。在文件src/serialize.h中，2012年9月提交的一个版本b019ea17ec7cc37d098982b4f0f4636e424ab4b8，我们可以看到一些历史代码： 在阅读比特币源码过程中发现了一个有趣的问题。在文件src/serialize.h中，2012年9月提交的一个版本b019ea17ec7cc37d098982b4f0f4636e424ab4b8，我们可以看到一些历史代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#ifdef TESTCDATASTREAM// VC6sp6// CDataStream:// n=1000 0 seconds// n=2000 0 seconds// n=4000 0 seconds// n=8000 0 seconds// n=16000 0 seconds// n=32000 0 seconds// n=64000 1 seconds// n=128000 1 seconds// n=256000 2 seconds// n=512000 4 seconds// n=1024000 8 seconds// n=2048000 16 seconds// n=4096000 32 seconds// stringstream:// n=1000 1 seconds// n=2000 1 seconds// n=4000 13 seconds// n=8000 87 seconds// n=16000 400 seconds// n=32000 1660 seconds// n=64000 6749 seconds// n=128000 27241 seconds// n=256000 109804 seconds#include &lt;iostream&gt;int main(int argc, char *argv[])&#123; vector&lt;unsigned char&gt; vch(0xcc, 250); printf("CDataStream:\n"); for (int n = 1000; n &lt;= 4500000; n *= 2) &#123; CDataStream ss; time_t nStart = time(NULL); for (int i = 0; i &lt; n; i++) ss.write((char*)&amp;vch[0], vch.size()); printf("n=%-10d %d seconds\n", n, time(NULL) - nStart); &#125; printf("stringstream:\n"); for (int n = 1000; n &lt;= 4500000; n *= 2) &#123; stringstream ss; time_t nStart = time(NULL); for (int i = 0; i &lt; n; i++) ss.write((char*)&amp;vch[0], vch.size()); printf("n=%-10d %d seconds\n", n, time(NULL) - nStart); &#125;&#125;#endif 这段代码是用来测试CDatastream类与C++标准库std::stringstream的性能的。在作者的测试结果中我们可以看到CDatastream的性能远远好于std::stringstream，然后我们再看一看编译平台：VC6SP6Orz… 大写的懵逼 VC6… 之所以要说懵逼，是因为CDatastream是一个很底层的类，用于所有全节点之间数据同步的，也就是说，所有的消息需要封装成CDatastream的形式再进行发送。再想一想比特币那几十G的全节点数据，是不是很爆炸。 那么我们在来看一看现在这段代码的性能对比：我基于ubuntu 16.04 LTS 进行测试，gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.1)机器的配置很一般一般，一般到什么程度呢？这是8年前的电脑，酷睿双核的哪种。 测试结果：1234567891011121314CDataStream:n=1000 0 secondsn=2000 0 secondsn=4000 0 secondsn=8000 0 secondsn=16000 1 secondsn=32000 0 secondsn=64000 1 secondsn=128000 2 secondsn=256000 5 secondsn=512000 9 secondsn=1024000 18 secondsn=2048000 37 secondsn=4096000 73 seconds 1234567891011121314stringstream:n=1000 0 secondsn=2000 0 secondsn=4000 0 secondsn=8000 0 secondsn=16000 0 secondsn=32000 0 secondsn=64000 0 secondsn=128000 0 secondsn=256000 0 secondsn=512000 0 secondsn=1024000 1 secondsn=2048000 0 secondsn=4096000 1 seconds 我在阿里云上也进行了测试, ubuntu 14.04 LTS, gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.1), 双CPU双Core1234567891011121314CDataStream:n=1000 0 secondsn=2000 0 secondsn=4000 0 secondsn=8000 0 secondsn=16000 1 secondsn=32000 0 secondsn=64000 1 secondsn=128000 1 secondsn=256000 3 secondsn=512000 5 secondsn=1024000 9 secondsn=2048000 19 secondsn=4096000 39 seconds 1234567891011121314stringstream:n=1000 0 secondsn=2000 0 secondsn=4000 0 secondsn=8000 0 secondsn=16000 0 secondsn=32000 0 secondsn=64000 0 secondsn=128000 0 secondsn=256000 0 secondsn=512000 0 secondsn=1024000 0 secondsn=2048000 1 secondsn=4096000 1 seconds 通过测试好像知道了些什么，不太清楚古老的VC6的标准库实现标准是什么，总之stringstream的性能应该是特别感人，才导致了satoshi先生不得不自己去打造一个看起来不那么搓的数据流类。另外一个例证是 [Bitcoin-development] CDataStream 开发者的交流邮件，我们可以看到基于 i686-apple-darwin11-llvm-g++-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.1.00 版本的测试性能：1234567891011121314CDataStream:n=1000 0 secondsn=2000 0 secondsn=4000 0 secondsn=8000 0 secondsn=16000 0 secondsn=32000 0 secondsn=64000 1 secondsn=128000 1 secondsn=256000 2 secondsn=512000 4 secondsn=1024000 8 secondsn=2048000 17 secondsn=4096000 40 seconds 1234567891011121314stringstream:n=1000 0 secondsn=2000 0 secondsn=4000 0 secondsn=8000 0 secondsn=16000 0 secondsn=32000 0 secondsn=64000 0 secondsn=128000 0 secondsn=256000 0 secondsn=512000 0 secondsn=1024000 0 secondsn=2048000 1 secondsn=4096000 2 seconds 所以我们的推断就是市场上主流的C++编译器随着时间的推移以及无数开源贡献者的贡献，std::stringstream已经经过了极大的优化，远超VC6是自然而然的事情，这点我们也可以从bitcoin/bitcoin 的 git history中可以看到：source link click me12345678910Remove VC6 comment and pointless #ifdef&apos;d benchmark codeWe&apos;re in a wholly different world now, C++-compiler-wise.Current std::stringstream implementations don&apos;t have the stated problem anymore,and are just as fast as CDataStream.The #ifdef&apos;d block does not even compile anymore; CDataStream constructor changed,and missing some std::. Also timing in whole seconds is also way too granularto say anything sensible in such microbenchmarks. Just remove it,it can always be found again in git history. 可以感受到作者深深的无奈。 当然performance是其中一个方面，在可定制的要求上也应该是很强烈的，这也促成了CDatastream类的一直延续。在bitcoinv0.12版本的代码中，我们可以看到serialize.h的实现并没有特别大的变更，只是想一些数据类型做了规范化的重载，并且去掉了预编译宏与模板的交叉代码。所以在bitcoind的最新代码上我没有再次进行CDatastream与std::stringstream的性能测试，感兴趣的可以试一下。另外，如果也是想通过C++完全自己实现一个类bitcoin的系统，一个的可行建议是实现std::stringstream 的wrapper来实现数据的流化，来降低工作量。]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论联盟链局限性与公有链]]></title>
    <url>%2Farchives%2F08-on-limitation-of-private-chain.html</url>
    <content type="text"><![CDATA[本篇探讨联盟链的局限性，并与公有链的关系。在本文中，我们定义联盟链为共享认证型区块链（Shared Permission Blockchain），与公有链的主要区别在于Permission上。 一. 从假设的银行联盟链DAO说起现考虑银行联盟链模型，假设存在一个银行业区块链联盟，每个联盟节点是一个共识节点，即该数据包含了该银行的核心业务数据（客户信用，借贷账目etc）以形成一个联盟链DAO，那么我们有： 1. 所有的银行客户信用数据是共享且共识的，即某s在A银行是VIP客户，信用非常良好，那么我们有：s去到该联盟链另一家银行办理业务时，该行需要承认s的信用。即信用共享，那么我们在信用共享时会遇到一个问题，如何对信用评级目前无法达成一致共识，即一定存在不同的节点，针对s的信用的评级差距过大，无法达成共识。本问题即退化成：如何使信用数据达成共识，首先要使不同银行节点在信用评级上有可遵循的标准，该标准是可量化的。根据现有的银行金融体系，目前看起来是做不到的。 本篇探讨联盟链的局限性，并与公有链的关系。在本文中，我们定义联盟链为共享认证型区块链（Shared Permission Blockchain），与公有链的主要区别在于Permission上。 一. 从假设的银行联盟链DAO说起现考虑银行联盟链模型，假设存在一个银行业区块链联盟，每个联盟节点是一个共识节点，即该数据包含了该银行的核心业务数据（客户信用，借贷账目etc）以形成一个联盟链DAO，那么我们有： 1. 所有的银行客户信用数据是共享且共识的，即某s在A银行是VIP客户，信用非常良好，那么我们有：s去到该联盟链另一家银行办理业务时，该行需要承认s的信用。即信用共享，那么我们在信用共享时会遇到一个问题，如何对信用评级目前无法达成一致共识，即一定存在不同的节点，针对s的信用的评级差距过大，无法达成共识。本问题即退化成：如何使信用数据达成共识，首先要使不同银行节点在信用评级上有可遵循的标准，该标准是可量化的。根据现有的银行金融体系，目前看起来是做不到的。 2. 借贷账目共享，联盟坏账可控，那么我们有：即存在一个利益分配策略，使得，各个节点在利益分配时能够按照一定权重进行分配。那么我们需要一个投票系统。 3. 投票系统该投票系统必须尽可能地反映各个联盟间节点话语权重的变化，即利益分配策略不能滞后实际的节点（贡献）实力。那么如何设计这个投票系统，目前来看是一个比较困难的问题。 二、有关联盟链的两个推论我们根据联盟链的用途，把联盟链分为价值联盟链和公证联盟链。价值联盟链是指能够内部转移资产所有权的联盟链，公证联盟链很好理解，仅限一些关键数据自证、披露、防篡改等功能。有了以上两个概念，我们有两条关于价值联盟链的Law， Law 1. 价值联盟链必须是跨行业的； Law 2. 在价值联盟链上+智能合约，无法形成稳定的DAO； 有关Law1, 证明如下： 如果价值联盟链是同行业的企业间共识一条链，那么由于同行业竞争关系，并没有这样的需求，使价值可以流通。这与连通器原理是类似的，当同行业间共识，价值在所有Entity间看起来是平的。 有关Law2，证明如下： 如果在价值联盟链上存在可编程的智能合约，那么由于联盟链的许可进入特性，智能合约的作用有限，如联盟链中大BOSS节点可以通过黑箱操作欺骗Oracle，让Data feed失效或者使规则偏袒自己。即智能合约以及Oracle无法发挥应有的特性，大BOSS节点往往可以通过其他方式绕过共识节点。那么结论就是，这是一个不稳定的DAO系统。 三、竞争联盟链与非竞争联盟链有关Law1，我们有如下更细致分类：如果价值联盟链是不同行业的企业间共识一条链，如A、B、C来自三个不同行业的企业，他们选取了一个积分产品作为流通资产，挂载在联盟链1，那么我们有，当同样是D、E、F来自三个不同行业的企业（与ABC的关系不确定），他们也选取了某个产品作为流通资产，挂载在联盟链2那么，联盟链2所流通的资产同样是积分产品时，那么我们称联盟链1和联盟2的关系为：竞争联盟链，否则称之为非竞争联盟链。在非竞争联盟链中，我们有一个很重要的隐性概念——协作区块链，即当联盟2所流通资产和积分资产在业务上是互补关系时，那么联盟链1和2是可以协作的。那么协作区块链是否可以发展为公有链呢？答案是不确定的，第一取决于协作区块链的规模，其次取决于联盟链的实际控制节点是否会弱化自己的权力，并淡化permission的准入许可。 四、联盟生态链？我们在第二节阐述了联盟链的两个推论，本节我们再扩充一下联盟链的内涵——联盟生态链，这里的生态是指业务生态，产品生态，与乐视，小米曾经提出的生态的概念是类似的。假设存在一个联盟链解决了一个核心业务流程的数据记录问题，那么我们有该区块链能够满足一定模式，该模式能够推广到该行业大部分相同种类的业务。那么我们依然无法解决这种业务单一性带来的不稳定性，即联盟链的特殊性无法与其他传统技术融合，形成壁垒，反而降低流通效率。 假设我们存在一条联盟生态链，满足企业的全部生命周期活动以及覆盖了全部的业务线，那么必存在一个智能合约集合，能够替代现有的流程，那么当该行业与外在发生联系时，该联盟链必须有一条出口，能够满足智能合约，满足数字资产内外流动，那么势必存在一个基础价值媒介（它可能是比特币，也有可能是央行发行的数字货币）能够满足这种内外流通需求，所以使用联盟生态链的前提是必须有基础货币的支持，那么也就是说，无论什么形式联盟生态链，都必须符合一条公有链的协议接口。然而联盟链还有另外一个隐藏的问题，即内部生态的进化速度完全比不上公有链Dapp的进化速度，这也会导致联盟生态链很容易受到公有链生态的冲击而名存实亡。 五、退化的数字身份认证和仲裁服务上篇我们讨论了智能合约的四大砥柱，其中有两个关键角色，第一是Oracle，第二是数字身份认证DI。 这两个角色会在联盟链中极度退化，数字身份认证DI会退化成一个不兼容的账户模型，Oracle会退化成一个简单的顾问服务。 所以缺失了这两项，智能合约是力不从心的，DAO更无从谈起了。 六、BaaS，区块链即服务我认为2016区块链国际峰会上提出的BaaS几乎都是不正确的。 并不是说将共识节点，客户端服务搭载在现有的云服务商上就是BaaS了，我认为必须是类以太坊的公有链服务，所有发行的数字资产可以嵌入到这条公有链，也可以脱离该公有链，该公有链只提供最基础的接口： 创建，发行，交换，验证，关闭。在这里区块链才是服务，而不是云服务器提供容器，容器装载区块链，区块链再提供服务，否则它只能退化成云服务平台的一个附属品，一个第三方云服务商给你搭载一个节点，怎么能称之为服务呢？区块链提供基础接口，开发者们根据这些基础接口开发各类各样的Dapp，这些Dapp跑在这条公有链上，这个公有链是S(ervice)，这些带智能合约的Dapp才是那个B(lockchain)。 那么BaaS应该如何实现？毫无疑问，共识机制是一条公有链的核心要素，这个共识机制如何能提供一条基础的演化稳定的基础协议能供人们开发，非常重要。其次，我们需要一个虚拟机（virtual machine），这个虚拟机承载智能合约，智能合约操作资产，资产通过Dapp发行，Dapp通过一个（wallet as a browser）来访问。这个过程才应该称之为BaaS。 我非常有幸在2016区块链国际峰会上和帅初大神交流了一些想法，我们一致认为开发者需要一个这样的开源项目，能够开发出一套兼容性强，通用性强的虚拟机，通过这个开源项目我们将智能合约虚拟机演化到一个非常成熟非常工业化的一个版本，那么智能合约指日可待。 七、总结如果说联盟链是一个本科生，那么公有链就是一个博士生，他们的上限和格局是不同的，所以说区块链在现阶段落地做项目，合适的切入点是联盟链，但如果要完成区块链的使命，非公有链莫属。公有链可以派生出联盟链，反之未必。]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>区块链 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建一个区块链交易所需要什么？]]></title>
    <url>%2Farchives%2F07-build-digital-asset-exchange.html</url>
    <content type="text"><![CDATA[一个交易所到底应该具备什么要素呢？ 交易所核心功能——撮合引擎。撮合引擎其实是一个交易所的核心模块，实现起来依据几条非常简单的原则： 成交价格优先-时间优先 定价时间优先-价格优先 卖方价格队列大于等于买方价格队列 一个交易所到底应该具备什么要素呢？ 交易所核心功能——撮合引擎。撮合引擎其实是一个交易所的核心模块，实现起来依据几条非常简单的原则： 成交价格优先-时间优先 定价时间优先-价格优先 卖方价格队列大于等于买方价格队列 但是里面的实现还是很讲究的： a. 高可用，撮合引擎宕机如何处理？ b. 实时成交，撮合引擎要求高速处理，IO一般都会成为瓶颈，如果避免IO是个非常有技术含量的问题。 c. 用户接口设计 这里的用户接口设计分： 下单HTTP API，以及响应式设计的web app。 d. pre-matching 的 订单校验与审核 交易所核心数据——资产与账户。围绕这撮合引擎又能引申出两个系统： 账户管理系统 账户底下又会细分 管理账户，普通账户，一级账户/二级账户，做市账户 资产管理系统 资产底下又会细分为 传统资产，数字资产， 并且资产有不同的形式，理财式的，货币类型的，股权类型的等等 一切皆资产，一切皆账户，围绕这两个系统，又会引申出第三个系统——权限管理系统。 以上的分析均基于传统的交易所，那么如果我们考虑用区块链呢？ 账户和资产的表示，以及权限管理将全部托管到区块链上。 这里又会细分： 包含代币的区块链系统非代币的区块链系统其中包含代币的区块链系统，表示为I型架构，非代币的表示为II型架构。 在I型架构下，代币系统未必是一个稳定的系统， 当代币系统足够大的时候但远不及货币的时候，代币作为资产将不稳定，不能作为计价单位。 当代币系统很小的时候，很难作为资产进行买卖。 其次I型架构，代币如何发行是个很麻烦的问题。 无论I型还是II型架构，传统区块链的提供的交割速度也是个问题，远远不能满足交易所的并发量以及速度，这时候就必须在共识模型上进行调整。 最后一个问题是如何将撮合引擎与区块链对接，最直观的方式是： 在撮合引擎节点上，部署一个区块链完全节点，并且该节点是共识节点，所有账户信息由该区块链节点维护，撮合引擎维护账户系统的最小集合——地址和余额。 发起交易直接调用区块链Client API即可。 当然更好的方式是作为架构集成，中间用消息中间件通讯，降低本地IO的开销。 先写这么多，想到了后续会补充，以及上述各问题的解决思路。 以上是针对任意数字资产发行的一种exchange的思路，一定会有童鞋提及bitshares的完全体区块链架构，这个也后续再更，继续挖坑~~~(￣︶￣)↗]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>区块链 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈区块链共识机制与分布式一致性算法]]></title>
    <url>%2Farchives%2F06-consensus-algorithm-introduction.html</url>
    <content type="text"><![CDATA[本文通过介绍传统分布式一致性算法和区块链共识模型，以及提出了一些有关两者关系的观点，让大家有个比较系统的了解。 一、前言本文打算先提出观点。欢迎大家参与讨论。 1. 传统分布式一致性算法和区块链共识过程的异同点相同点： Append only 强调序列化 少数服从多数原则 分离覆盖的问题：即长链覆盖短链区块，多节点覆盖少数节点日志 不同点： 传统分布式一致性算法大多不考虑拜占庭容错(Byzanetine Paxos除外)，即假设所有节点只发生宕机、网络故障等非人为问题，并不考虑恶意节点篡改数据的问题； 传统分布式一致性算法是面向日志（数据库）的，即更通用的情况，而区块链共识模型面向交易的，所以严格来说，传统分布式一致性算法应该处于区块链共识模型的下面一层。 本文通过介绍传统分布式一致性算法和区块链共识模型，以及提出了一些有关两者关系的观点，让大家有个比较系统的了解。 一、前言本文打算先提出观点。欢迎大家参与讨论。 1. 传统分布式一致性算法和区块链共识过程的异同点相同点： Append only 强调序列化 少数服从多数原则 分离覆盖的问题：即长链覆盖短链区块，多节点覆盖少数节点日志 不同点： 传统分布式一致性算法大多不考虑拜占庭容错(Byzanetine Paxos除外)，即假设所有节点只发生宕机、网络故障等非人为问题，并不考虑恶意节点篡改数据的问题； 传统分布式一致性算法是面向日志（数据库）的，即更通用的情况，而区块链共识模型面向交易的，所以严格来说，传统分布式一致性算法应该处于区块链共识模型的下面一层。 2. 区块链共识模型与传统一致性算法的关系考虑上面的不同点，结合私有链和行业链的性质，我们有： 私有链：封闭生态的存储网络，所有节点都是可信任的，如某大型集团内部多数公司。 行业链：半封闭生态的交易网络，存在对等的不信任节点，如房地产行业A、B、C、D公司。 公有链：开放生态的交易网络，这层主要是为行业链和私有链提供全球交易网络。由于私有链是封闭生态的存储网络，也就是说使用传统分布式一致性模型应该是最优的； 由于联盟行业链其半封闭半开放特性，使用Delegated Proof of XXX 是最优的，可以考虑以传统一致性算法作为基础加入拜占庭容错/安全防护机制进行改进。公有链PoW应该仍然是最优的选择。如下图所示： 二、传统分布式一致性算法介绍本文主要讨论主流的Paxos算法家族和Raft算法，这里抛砖引玉，网络上有关两者的资料非常丰富，大家可自行搜索查阅。 1. Paxos 算法家族1998年Lamport提出Paxos算法，后续又增添多个改进版本的Paxos形成Paxos协议家族，且Paxos都有共同点是不容易工程实现。 Classic Paxos ：LeaderLess，又名Basic Paxos，以下均为Paxos的变种，基于CAP定律，侧重了不同方向。Cheap PaxosEgalitarian Paxos ： conflicts rareFast Paxos ： Leader only when needed ，conflicts commonMulti-Paxos ：Leader drivenByzanetine Paxos“Byzantine Paxos adds an extra message (Verify) which acts to distribute knowledge and verify the actions of the other processors”.Lamport 在2011年的论文《Leaderless Byzanetine Paxos》中表示不清楚实践中是否有效，考虑Paxos本身实现的难度，此方案工程角度不是最优，但是系统角度应该是最好的。 本小节Ref： Wikipedia_Paxos Leaderless Byzanetine Paxos 2.Raft 算法这是一个非常友好的算法，容易理解、实现，不过它是Strong Leadership的，也就是说， 任意包含Leader的时刻，Leader拥有完全记账权，如果此Leader节点是恶意的，后果不堪设想。 且leadership的一致性算法都有个通病，吞吐量受单个节点的限制，这点在Raft身上体现尤甚。 Raft算法简介：https://raft.github.io/ Raft算法动态演示：http://thesecretlivesofdata.com/raft/ 3. 其他VRR(Viewstamped Replication Revisited)这也是一个基于leadership的一致性算法，相比上述其他算法，它的优点是延迟最小。 三、常见区块链共识模型介绍转载自这里：https://bitsharestalk.org/index.php?topic=4031.0 这是DPoS的白皮书，主要介绍了DPos，但也囊括了其他共识模型的介绍。 授权股权证明机制白皮书(Delegated Proof-of-Stake ，DPOS)作者： Daniel LarimerApril 3, 2014翻译：yidaidaxia_郝晓曦比特坊数字资产研究俱乐部 翻译作品（www.bitfarm.io） 摘要本白皮书介绍一种股权证明机制的新实现方式，该方式可以对交易进行秒级验证，并且能够在更短的时间内提供比现有任何股权证明系统都更好的安全性。在比特币网络产生一个区块的时间过后，一个授权股权证明系统(DPOS)能使你的交易得到20%股东的核实，而在比特币网络声明交易已几乎不可逆(6个区块，约1小时)的时间过后，在DPOS机制下，通过其代表，你的交易已经得到100%股东的核实。 1.0 背景分布式交易总账需要在尽可能短的时间内做到安全、明确及不可逆，便于提供一个最坚实且去中心化的系统。在实践中，该流程分为两个方面：选择一个独特的节点来产生一个区块，并使得交易总账不可逆。 1.1 工作量证明机制(Proof of Work, POW)第一个成功解决该问题的尝试是比特币系统(Bitcoin)，比特币系统使用工作量证明机制使更长总账的产生具有计算性难度。工作量证明机制就好比是乐透，平均每10分钟有一个节点找到一个区块。如果两个节点在同一个时间找到区块，那么网络将根据后续节点的决定来确定以哪个区块构建总账。从统计学角度讲，一笔交易在6个区块(约1个小时)后被认为是明确确认且不可逆的。然而，核心开发者认为，需要120个区块(约一天)，才能充分保护网络不受来自潜在更长的已将新产生的币花掉的攻击区块链的威胁。尽管出现更长的区块链会变得不太可能，但任何拥有巨大经济资源的人都仍有可能制造一个更长的区块链或者具备足够的哈希算力来冻结用户的账户。 1.2 股权证明机制(Proof of Stake, POS)股权证明机制已有很多不同变种，但基本概念是产生区块的难度应该与你在网络里所占的股权(所有权占比)成比例。到目前为止，已有两个系统开始运行：点点币(Peercoin)和未来币(NXT)。点点币使用一种混合模式，用你的股权调整你的挖矿难度。未来币使用一个确定性算法以随机选择一个股东来产生下一个区块。未来币算法基于你的账户余额来调整你被选中的可能性。未来币和点点币都分别解决了谁来生产下一个区块的问题，但他们没有找到在适当的时间内使区块链具备不可逆的安全性的方法。根据我们能找到的信息，做到这点，点点币需要至少6个区块(约一小时)，未来币需要10个区块。我们找不到在10个区块后未来币能提供什么级别安全性的根据。我们之前发布了基于交易的股权证明机制(Transactions as Proof of Stake, TaPOS)的白皮书，在该机制中，每笔交易都包含区块链中前一个区块的哈希值。通过该系统，对任何人而言，网络变得越来越安全而不可逆，因为最终每个区块都经过了股东投票。TaPOS面临的挑战是它没有定义谁来产生下一个区块。 1.3 瑞波共识机制(Ripple Consensus)瑞波共识算法，使一组节点能够基于特殊节点列表达成共识。初始特殊节点列表就像一个俱乐部，要接纳一个新成员，必须由51%的该俱乐部会员投票通过。共识遵循这核心成员的51%权力，外部人员则没有影响力。由于该俱乐部由“中心化”开始，它将一直是“中心化的”，而如果它开始腐化，股东们什么也做不了。与比特币及点点币一样，瑞波系统将股东们与其投票权隔开，并因此比其他系统更中心化。 2.0 授权股权证明机制(DPOS)当使用去中心化自治公司(Decentralized Autonomous Company, DAC)这一说法时，去中心化表示每个股东按其持股比例拥有影响力，51%股东投票的结果将是不可逆且有约束力的。其挑战是通过及时而高效的方法达到51%批准。为达到这个目标，每个股东可以将其投票权授予一名代表。获票数最多的前100位代表按既定时间表轮流产生区块。每名代表分配到一个时间段来生产区块。所有的代表将收到等同于一个平均水平的区块所含交易费的10%作为报酬。如果一个平均水平的区块含有100股作为交易费，一名代表将获得1股作为报酬。网络延迟有可能使某些代表没能及时广播他们的区块，而这将导致区块链分叉。然而，这不太可能发生，因为制造区块的代表可以与制造前后区块的代表建立直接连接。建立这种与你之后的代表(也许也包括其后的那名代表)的直接连接是为了确保你能得到报酬。该模式可以每30秒产生一个新区块，并且在正常的网络条件下区块链分叉的可能性极其小，即使发生也可以在几分钟内得到解决。 2.1 成为一名代表成为一名代表，你必须在网络上注册你的公钥，然后分配到一个32位的特有标识符。然后该标识符会被每笔交易数据的“头部”引用。 2.2 授权你的选票每个钱包有一个参数设置窗口，在该窗口里用户可以选择一个或更多的代表，并将其分级。一经设定，用户所做的每笔交易将把选票从“输入代表”转移至“输出代表”。一般情况下，用户不会创建特别以投票为目的的交易，因为那将耗费他们一笔交易费。但在紧急情况下，某些用户可能觉得通过支付费用这一更积极的方式来改变他们的投票是值得的。 2.3 保持代表诚实每个钱包将显示一个状态指示器，让用户知道他们的代表表现如何。如果他们错过了太多的区块，那么系统将会推荐用户去换一个新的代表。如果任何代表被发现签发了一个无效的区块，那么所有标准钱包将在每个钱包进行更多交易前要求选出一个新代表。 2.4 解决区块链分叉和工作量证明系统及其他股权证明系统一样，最佳区块链是最长的有效区块链。任何时候，一名代表错过签发一个区块的机会，该区块链将比潜在竞争对手短。只要在你的交易被写入区块后的100个区块中的51%被生产出来了，那么你就可以安全地认为你在主区块链上。也许，在防止区块链分叉所导致的损失方面，最重要的事是在事发后第一时间得知消息。因为代表们通过生产区块得到很好的报酬，他们将保持接近100%的在线时间来防止因被投票罢免而损失收入。你可以安全地认为如果在过去的10个区块中，有一两个区块错过生产，则互联网的某些部分可能正发生连接问题，那么用户应该对此特别警觉并要求额外的确认数。如果10区块中有超过5个错过生产，那么这意味着你很可能在一条支链上，因此应该停止所有交易，直到分叉得到解决。以一种及时的方式(少于5分钟)简单地发现并警示用户网络分叉，是可以最小化潜在损失的非常重要的能力。而知道你是否正处在一条支链上则更为重要。 2.5 100名代表是去中心化的吗？因为去中心化已经成为一个流行术语，所以其定义很难完全固定。我们将自由市场看作去中心化的基本形式，并将对进入自由市场设置障碍看作是所有中心化的基础。像任何事物一样，中心化有程度之分，所以我们把授权股权证明机制与其它方案的中心化程度进行对比。 2.5.1 比特币比特币系统目前正以授权工作量证明(Delegated Proof of Work, DPOW)为基础而运行，因此有大约10名代表控制了绝大多数的哈希算力。在那些为其竞争而能使用规模经济进行无收益挖矿的人手中，哈希算力本身就是中心化的。最后，工作量证明机制为进入市场设置障碍，使得“在职”的区块制造者无法轻易被取代。与比特币系统相比，DPOS在区块生产方面至少去中西化了10倍，并且也许在市场竞争方面去中心化了无数倍。尽管在哈希算力方面有一定量的去中心化，当想到掌控比特币系统的股东(比特币持有者)所持股份的占比，我们认为比特币系统是最中心化的。如果你考虑使用比特币体系的用户总数，其中参与挖矿的人很可能少于百分之一。 2.5.2 点点币点点币是一个混合系统，所以它由于工作量证明机制而是部分中心化的。和比特币系统一样，它也有矿池。与比特币相比，点点币无疑是更去中心化的，然而，因为股权证明机制矿池需要用户保持他们的电脑在线且钱包解锁，只有一小部分的股东参与了任何形式的挖矿。 2.5.3 未来币未来币使用透明锻造，以确定的选出下一个制造节点。可以将其类比为，使用授权股权证明机制但你只能将你的投票权授予你自己，而你获得锻造区块机会的频率直接取决于你的账户余额。在这个意义上来说，未来币比点点币和比特币更为去中心化。但由于对安全风险的顾虑以及事实上大多数常规用户不会整天开启他们的电脑来籍此获得锻造机会方面的优势，它仍然遭受着少的可怜的挖矿参与度。从这个角度来讲，我们可以断定未来币网络是由一小部分股东来保障网络安全的。事实上，如果你不上线投票，那么你将失去你的选票。为了解决这个问题，一些未来币用户用他们的股权建立股权池，并信任第三方来为他们挖矿。这是以一种形式的授权股权证明来提高股东参与度，但这也使他们的账户余额在他们参加这些矿池时承受风险。 3.0 攻击一般而言，网络必须抵御两种类型的攻击：拒绝服务攻击和双重支付攻击。一个攻击者通过不把一些或全部的交易加入总账来进行拒绝服务攻击。这种攻击可以由任何拥有51%网络(无论比特币、未来币或其它)的人进行。而利用在网络正试图达成共识时的短期优势，可以进行双重支付攻击。为抵御这些攻击，网络必须使51%的股东尽快达成协议。 3.1 防止排除交易拥有全部经股东投票选出的100名代表，并且按要求轮流生产区块，意味着任何一笔由至少1%的股东批准的交易能够在30分钟内加入总账。这意味着没有代表可以通过将投票支持其他代表的交易排除在外来获取利益。 3.2 将一些代表的权力中心化与其所被授权的投票权无关，这前100人所获得的权力权重是相同的，每名代表都有一份相等的投票权。因此，无法通过获得超过1%的选票而将权力集中到一个单一代表手上。个人或者组织控制区块链的多名代表是有可能的。但是这个过程将需要欺骗很大比例的股东数去支持“傀儡”。即使可以建立这51%傀儡，他们扰乱网络的能力仍将是有限的、能够被快速识别快速纠正的。没有工作量证明机制设置的进入障碍，占据多数的诚实用户会把攻击鉴别出来，然后将代码分叉并无视攻击者生产的区块。这种攻击可以扰乱网络，但不会是致命的。 3.3 针对代表的分布式拒绝服务攻击(DDOS)因为只有100名代表， 可以想象一个攻击者对每名轮到生产区块的代表依次进行拒绝服务攻击。幸运的是，由于事实上每名代表的标识是其公钥而非IP地址，这种特定攻击的威胁很容易被减轻。这将使确定DDOS攻击目标更为困难。而代表之间的潜在直接连接，将使妨碍他们生产区块变得更为困难。 4.0 基于交易的股权证明机制(TaPOS)代表制是一个短时间内达成坚固共识的高效方式，而TaPOS为股东们提供了一个长效机制来直接批准他们的代表的行为。平均而言，51%的股东在6个月内会直接确认每个区块。而取决于活跃流通的股份所占的比例，差不多10%的股东可以在几天内确认区块链。这种直接确认保障了网络的长期安全，并使所有的攻击尝试变得极度清晰易见。 5.0 高质量的服务假设一个DPOS系统拥有100亿美元的市场总量，平均每年的交易费为0.25%，代表们合计获得所有交易费的10%，那么每名代表每年能获得25,000美元以使其节点保持在线。这是一个利润可观的角色，许多人将为获取它持续竞争。这意味着每个想要获得这份工作的人都会想方设法从拥有这份工作的人那里把它“偷走”。为做到这点，他们将对代表行为进行统计学分析，以找到对于标准算法的任何偏离行为。一旦找到这种偏离，他们就能有希望赢得一些选票。那些拥有这份工作的人，可能会全力以赴地证明他们正在按标准软件运行。他们越有效地证明其对区块生产的正直性，越有可能保住他们的工作。你可以想象开发者会很快制作出系统，代表们可以通过这些系统快速证明哪些交易得到了广泛的散播。事实上，市场竞争将产生用以证明代表们的正直性与可靠性的最具创造性的解决方案。让网络变得更安全的工作可以获得很多收益，而尝试绕轮网络则得不到什么好处。 6.0 结论DPOS流程与TaPOS结合所产生的网络，其网络共识的可证明性将至少3倍于比特币、点点币及未来币网络。DPOS能够更快地达成共识，同时消除随机小股东带来小规模干扰的可能性。经济激励确保了代表们致力于证明他们有良好行为，并可能采用类似于瑞波系统的共识算法(来实现这种证明)。DPOS，事实上，是一种通过无网络分叉之虞的去中心化方式来产生瑞波特殊节点列表的方法。]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>区块链 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读"三巨人"的源码-比特币]]></title>
    <url>%2Farchives%2F11-how-to-learning-btcsrc.html</url>
    <content type="text"><![CDATA[前言 由于有很多新生区块链技术学习者，问我如何入门这些代码，所以打算放一篇文来介绍下。 相较于中文资料各种教程类文章，本系列文章侧重源码架构和分析。 这里所说的三大巨人是指：比特币，以太坊，比特股。其他微创新的代码可以以这些代码为base进行扩展研读，所以只打算介绍这三巨人。 由于本人是CXX工程师，除了模块分析之外，其他源码的介绍主要以CXX的代码为主。 考虑到难度，这里以比特股的代码最为复杂，以太坊的代码其次也最为舒服， 而以上两个工程，都需要以比特币的源码作为支撑，而且比特币的代码算作区块链入门级的，即使对于CXX新手来说，也是可以一窥全貌的。 所以本文主要以比特币的源码作为切入，在后续系列的文章会接续介绍另外两个巨人。 （本文转载请告知，保留所有权利） 前言 由于有很多新生区块链技术学习者，问我如何入门这些代码，所以打算放一篇文来介绍下。 相较于中文资料各种教程类文章，本系列文章侧重源码架构和分析。 这里所说的三大巨人是指：比特币，以太坊，比特股。其他微创新的代码可以以这些代码为base进行扩展研读，所以只打算介绍这三巨人。 由于本人是CXX工程师，除了模块分析之外，其他源码的介绍主要以CXX的代码为主。 考虑到难度，这里以比特股的代码最为复杂，以太坊的代码其次也最为舒服， 而以上两个工程，都需要以比特币的源码作为支撑，而且比特币的代码算作区块链入门级的，即使对于CXX新手来说，也是可以一窥全貌的。 所以本文主要以比特币的源码作为切入，在后续系列的文章会接续介绍另外两个巨人。 本文的比特币源码主要以bitcoin-core 源码 v0.12 和 v0.8.2两个版本作为参考：https://github.com/bitcoin/bitcoin v0.8.2在挖矿上有优势，v0.12在代码上有优势，分别体现了0.8=&gt;0.9 hardfork 不同版本之间比较大的差异。 BTC模块图 比特币的源码模块一览： （图1） 从图中我们可以看出代码的脉络看起来非常清晰，其实不然，在每个模块之间还有很多过渡的小类，模块之间的联系也非常紧密。 比方说Wallet模块就和Transaction模块非常紧密，而P2P网络模块也和Transaction模块很紧密。 从分层的角度来看，所有代码都是以P2P网络协议为基础的事件机制作处理的。 如果要了解整个代码模块，可以先从P2P网络协议开始入手： Net.cpp Netbase.cpp 等类文件 当然入口函数也是需要先行了解的， 这里有我随手画的一张bitcoind启动函数栈调用一览： （图2） 另外在送一张BTCD (比特币Go语言客户端)的模块图，可以用作参考 （图3） 整体模块划分似乎和bitcoind差别不大，多了websocket，btcwire外面的东西。 如何阅读BTC源码 如果要以代码的角度来分析BTC源码，需要了解一些基础的类，比方基础类型定义，数据流处理相关的类，HASH处理相关的类，BigNum类等等。 结合上面的一些画图思路，读者应当在阅读源码的过程中提炼出类似的模块图，类图，时序图用以分析，也可以借助一些逆向工程工具生成有用的图表。 总体的脉络上来说，BTC的类设计是比较简单的，很多类都几乎接近POD类型，而且充斥着大量的public的成员变量。 因为从v0.8.2版本来看，很多代码混合了C++模板和C语言宏一起使用，充斥着大量的全局变量，这种现象到v0.12版本好了很多。 尤其我前篇文讨论CDataStream类，也可以看出，随着时代的发展，BTC的代码也一直在进化。 如果作为新手，建议两个版本的源码可以看看，因为很多的类未必需要如此设计，看起来比较变扭。 另外一个好玩的地方是0.12版本把挖矿相关的代码削弱了，所以如果不配合如 cpuminer或者bfgminer，很可能几个小时你也挖不到块。 最好的建议是两个版本混合使用v0.8版本的挖矿代码还是很给力的，10分钟一个块不玩虚的，而0.12版本用来测试交易。 随着版本的迭代，很多jsonrpc也是有变化的，最典型的是getwork命令在0.12版本消失了，变成了三个更具体的命令比如getnetworkinfo等。 所以在测试时以及搜索资料时，需要注意不要全信，尽量自己动手测试，因为这些文档很可能都过时了，尤其是好些中文资料，抄来抄去居多。 所以读者应尽量选择google+英文资料进行学习。 另外一个需要注意的地方是，在v0.8版本的挖矿代码中，我们注意到了使用了crypto++库，这是一个有关加密解密哈希相关的C++的库， 对密码学实现感兴趣的读者可以自己找这个库研究一番。]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链的联盟链开源项目介绍]]></title>
    <url>%2Farchives%2F05-opensource-blockchain-project.html</url>
    <content type="text"><![CDATA[以下一些私有链我选择性会进行实践，并给出说明，最后是比较评价，赶快mark吧~（作者保留权利，转载请联系) 1) https://github.com/hyperledger/hyperledgerHpperLedger是一个进行中的项目，目前还没决定使用哪个版本作为主线开发，但是提供了以下四个候选方案： （这些内容是HyperLedger项目还未确定的时候，现在已经确定叫Fabric, GO语言开发) a. https://github.com/ripple/rippled 瑞波币的推荐方案 实现语言：C++ 以下一些私有链我选择性会进行实践，并给出说明，最后是比较评价，赶快mark吧~（作者保留权利，转载请联系) 1) https://github.com/hyperledger/hyperledgerHpperLedger是一个进行中的项目，目前还没决定使用哪个版本作为主线开发，但是提供了以下四个候选方案： （这些内容是HyperLedger项目还未确定的时候，现在已经确定叫Fabric, GO语言开发) a. https://github.com/ripple/rippled 瑞波币的推荐方案 实现语言：C++ b. https://github.com/openblockchain IBM 推荐的 openblockchain 方案 实现语言：GO语言 c. https://github.com/DigitalAssetCom/hlp-candidate DAC本家的hlp 实现语言：JAVA d. https://github.com/ElementsProject/elements BlockStream 推荐的 elements 方案 实现语言：C++ 2) https://github.com/IBM-Blockchain/marblesIBM 本家基于bluemix云平台的推荐方案，与bluemix绑定 实现语言：js on Node.js 3) https://github.com/openchain/openchainCoinprism公司开源的openchain 实现语言；C# 4) https://github.com/HydraChain/hydrachain基于以太坊平台的私有链技术，名字好~ 摘要描述： HydraChain is an extension of the Ethereum platform which adds support for creating Permissioned Distributed Ledgers. Its primary domain of application are private chain or consortium chain setups. 5) https://github.com/myblockchain/myblockchain类SQL方式的Blockchain，很新颖有趣。 实现语言：C++ forked by: mysql-server 摘要描述： Start your own blockchain with the following simple command: 12345678CREATE TABLE blocks ( id INT, previous_block_id INT) TYPE=innodb;Don&apos;t forget to generate the Genesis block! Everyone can feel like Satoshi in the private Blockchain world!INSERT INTO blocks (id, previous_block_id) VALUES (42, NULL);Now you are free to create your own transactions, make coins appear out of thin air, send them to yourself or your friends, censor the transactions of your competitors and collect transaction fees that are actually worth your time. 6) http://www.multichain.com/一个构建私有区块链的伪开源平台，也许未来是商业的 7) https://erisindustries.com/带智能合约的区块链构建方案 8) http://blockstrap.com/html5 framework for blockchain applications 9)http://tendermint.com/developers/ 附录以上有很多基于HyperLedger展开的，以下是一些新更新的内容，含某些公有链： 智能合约系列 以太坊 Rootstock Eris Lisk 比特币扩展 Blockstream ColoredCoins CounterParty Liginting.Network 共识 比特币 点点币 比特股 私有链 multichain 国内项目 元界-Metaverse 布比联盟链 小蚁数字资产 BitSE-vechain]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>区块链 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建自己的区块链]]></title>
    <url>%2Farchives%2F04-build-your-own-blockchain.html</url>
    <content type="text"><![CDATA[一、 环境依赖OS 选择：ubuntu 14 ~ 15 均可为了减少实践过程中出现的大量的依赖库的安装的繁琐程度，推荐ubuntu，当然其他发行版的Linux也是可以的。 开发倚赖包：12345apt-get install libboost-all-devapt-get install opensslapt-get install libssl-devapt-get install libdb5.3++-devapt-get install libminiupnpc-dev secp256k1 库已经被包含，由于secp256k1库更新较快，必须match指定版本才能work，当前版本并不支持最新版本的secp256k1. 一、 环境依赖OS 选择：ubuntu 14 ~ 15 均可为了减少实践过程中出现的大量的依赖库的安装的繁琐程度，推荐ubuntu，当然其他发行版的Linux也是可以的。 开发倚赖包：12345apt-get install libboost-all-devapt-get install opensslapt-get install libssl-devapt-get install libdb5.3++-devapt-get install libminiupnpc-dev secp256k1 库已经被包含，由于secp256k1库更新较快，必须match指定版本才能work，当前版本并不支持最新版本的secp256k1. 代码获取： git clone https://github.com/betachen/ttcoin.git共识模型基于 Pow + Pos 二、编译本文只研究核心代码, qt部分代码不考虑，进入目录 ttcoin/src直接make, 如果编译过程中出现了not found某某依赖包，直接拷贝名称安装即可，需要注意版本大约等待10几分钟，编译完成可以看到生成了ttcoind。如果需要完全创建自己的区块链，请按照《从 0 到 1 建立自己的区块链》修改少量hard codeing的代码重新编译即可。其中hashGenesisBlock部分的代码已经在文件中，只需打开条件编辑即可生成创世块 三、尝试单机运行第一次运行需要配置一些简单的参数，根据提示设置即可默认交易端口是12009，使用debug命令可以在 ~/.ttcoin/debug.log 看到更详细的信息 1./ttcoind -debug因为是从bitcoin fork过来的，所以可以使用bitcoin绝大部分的JsonRPC:https://blockchain.info/api/json_rpc_api 四、挖矿当你的binary可以运行了，你真正的旅程才开始：先挖矿产出币，接下来再尝试多节点运行–&gt;多节点交易理想的情况是，运行Binary以后，会出块产生coinbase交易。 （挖矿分为SOLO和POOL两种方式SOLO单机就可以，但是效率会很低，初始块可能将近1个小时左右才能出来POOL挖矿可以线性减少时间） 五、尝试多节点运行bitcoin是一种P2P网络，可以使用下面的方式理解。假设存在A、B、C、D四个核心节点当B、C、D都和A链接时，A会告诉A都链接了谁，这样就形成互通的P2P网络。使用命令链接peer： ./ttcoind -debug -addnode=192.168.1.2 六、多节点相互交易可以参考bitcoind的用法进行交易 七、代码剖析ttcoind 是从 bitcoind.cpp 的 main函数进入的真正执行初始化的是AppInit2函数 1fRet = AppInit2(threadGroup);在AppInit2中我们可以看到起了约7个线程 （后续更新）]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>区块链 入门 比特币</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[货币的一种互联网体系架构]]></title>
    <url>%2Farchives%2F03-architecture-of-value-internet.html</url>
    <content type="text"><![CDATA[介绍中本聪最伟大的发明比特币，可以因为以下两处不同的特征广受赞誉： 比特币是公开的，去中心化的，加密总账（cryptographic ledger），同时拥有基本总账能力。加密总账能追踪新的比特币的余额。以比特币为基础的平行金融体系正在被着力打造当中。加密总账在灵活性上的便利开发诸多。例如多重签名账户，去中心化兑汇，机器间交易的新应用，而这些成为了开发的驱动力。这一论文分析加密总账在目前金融体系中的应用，同时促进对一下内容的讨论：如果金融机构利用公共加密去中心化总账，同时有基本总账能力，当他们检测资产负债余额情况时，哪些速度、成本、灵活性上面的优势可以达成？ 这些总账给实时全额结算系统（Real Time Gross Settlement）例如CHAPS和FedWire的构建带来了新的方式，同时还有延迟净额清算系统（Deferred Net Settlement）例如ACH，Bacs和对应银行，外汇交易市场，股票交易市场和其他金融体系的支柱。这篇文章把这些去中心化的元素压缩进一个基于层级的连续框架，同时称它为：货币的一种互联网体系架构 货币的一种互联网体系架构带来的可感知好处将会随着对系统的介绍一同枚举。这些好处是邀约的动机。 作者：Meher Roy翻译&amp;校对：初夏虎，沈至慧，陈浩原文地址 请自备梯子。 介绍中本聪最伟大的发明比特币，可以因为以下两处不同的特征广受赞誉： 比特币是公开的，去中心化的，加密总账（cryptographic ledger），同时拥有基本总账能力。加密总账能追踪新的比特币的余额。以比特币为基础的平行金融体系正在被着力打造当中。加密总账在灵活性上的便利开发诸多。例如多重签名账户，去中心化兑汇，机器间交易的新应用，而这些成为了开发的驱动力。这一论文分析加密总账在目前金融体系中的应用，同时促进对一下内容的讨论：如果金融机构利用公共加密去中心化总账，同时有基本总账能力，当他们检测资产负债余额情况时，哪些速度、成本、灵活性上面的优势可以达成？ 这些总账给实时全额结算系统（Real Time Gross Settlement）例如CHAPS和FedWire的构建带来了新的方式，同时还有延迟净额清算系统（Deferred Net Settlement）例如ACH，Bacs和对应银行，外汇交易市场，股票交易市场和其他金融体系的支柱。这篇文章把这些去中心化的元素压缩进一个基于层级的连续框架，同时称它为：货币的一种互联网体系架构 货币的一种互联网体系架构带来的可感知好处将会随着对系统的介绍一同枚举。这些好处是邀约的动机。 缩写和定义 ACH：自动清算系统，确保美国基于延迟净额清算基础的零售支付过程可行的系统。 Bacs：确保英国基于延迟净额清算基础的零售支付过程可行的系统 CHAPS：英国用来实施高价值交易的基础全额结算基金交易系统 Consensus Pool：一组服务器，拥有给定的主人，使用容错算法来持续达到共识状态的总账。健康的共识池（consensus pool）一般由不同对手方控制若果服务器。 DApp：去中心化应用 DE：去中心化交易 DEP：去中心化交易协议(protocol)，在7a部分有描述 DNS：延迟净额清算 DNSP：延迟净额清算协议，在7d部分有描述 FedWire：美国用来实施高价值交易的基础全额结算基金交易系统 Issuer：在加密总账上发放财产的对手方。这一对手方可以是一家银行，公司，去中心化的匿名机构，政府或者私人个体。财产可以是商品保障代币，货币，情报类货物，公司内部股权，代表航空里程的代币。 Ledger contracting：请在3,4小节找到释义 ODFI：初始存储金融机构，一家创立自动清算贷款的银行。 OFI：初始金融机构，一家创立FedWire贷款的银行。 RDFI：存储接受金融机构，一个结束ACH贷款的银行。 RFI：接受金融机构，一家结束FedWire贷款的银行。 RTGS：实时全额结算系统。 GTGSP：实时全额结算系统协议，在7c中有描述。 SIPS：重要支付系统。 SL3P：静态流动性支付过程协议，在7b中有描述 Tx：交易 框架由OSI层模型得到启发货币互联网构架按图一(Figure 1)进行：p1 接下来的部分详述每一层的需求和能力，论文和划分为以下分段： 4,5节描述了总账协议，由比特币和以太坊项目概念升级引领的创新。总账协议给此文多重组成建造了基础。在4小节对比特币的描述中，尽管在抽象有利情况下来看是正确的，但又与目前的实现有所偏离。 6,12,13小节讨论总账层，6小节做了整体假设，省略了理由。理由和详述在12小节。13小节的目的写在5小节。 7a，7b，7c和7d描述了DEP，SL3P，RTGSP和DNSP。这一段阐述了货币互联网的潜在核心创新。 8小节展示了7小节中的协议可以统一成两个基本的总账运行。这一联合使得实现易于处理。 9,10和11小节分别介绍了寻找的目标，协议一节程序层。 14小节展示了重要的观察和开发问题。参考文献在15小节，作者详细情况在16小节。 最后，便签颜色编码（本文是翻译文，不参照下述）： 深蓝色粗体 字体用于部分的标题。 天蓝色粗体字体用于分节标题。 绿色加粗字体demarate多相支付和交换协议阶段。 灰色加粗字体标出重要的定义，意见或段落。 文章详细介绍其他颜色和形状公约，以备不时之需。 比特币的总账合约总账协议是追踪价值余额账户的协议。它们允许客户在自己账户里减去X单元，同时在另一个账户里计入X单元。为了达成一个重要的运作，客户的账户必须有超过X的余额。图一形象化了两个花旗银行客户，Alice和Bob。Alice创立了这个支付。p2 在上图的运行中，比特币通过总账协议增加了财富。总账协议是保持余额的账户在预定规则下运作。比特币外部的实体，像Alice和Bob，在完成规则集(rule sets)前不能用总账协议来缔约。这一实施因为违背协议规则拒绝比特币节点来进行。 例如，Alice想要把比特币转给Bob，同时Bob只能在15年12月31日后使用比特币。创立一个保持比特币暂时余额的总账协议(ledger contract)就能进行。对Bob的转账，在总账协议中设置给定日期后才能获得比特币。图三展示了这个流程：p3 总账协议可以被认为是中立的，自动的第三方，调停Alice和Bob之间的转账关系。读者需要知道上面的图是一个抽象 (abstract ) 概念，比特币可以不同方式地来实施交易。p4 图四提供了第二个注释。Alice是一个买家，Bob是一个卖家。货物交易有个很长的运输时间。Trent是同时被Alice和Bob信任的第三方。在这一买卖中，Alice把买物价值存在总账协议，按以下条约： 三方中任意两个必须签约保证协议资金不能动。 如果货品错误接受，Alice和Trent能把资金给回Alice。 销售顺利结束，Bob和Trent把支付款项给到Bob。 图四展示了成功销售交货时候的交易流程。总账协议就像一个中立的自动第三方调停Alice，Bob和Trent直接的交易关系。 比特币总账协议由堆栈为基础的（stack-based）字节代码(bytecode)语言编程，我们叫它为“Bitcoin script”。每个总账协议都有代码和缓存数据结构。比特币协议系统有两个重要的限制： 价值盲区(value-blindness)：协议不能执行比总共存储在内的资金金额低的交易。也就是说检索时间内应用人要一次提出所有资金。 缺少持久储存/状态：协议不能存储数据，这限制应用人不能做去中心化交易。 图五展示了强调限制的假设情况。Alice想用总账协议把比特币换成狗狗币。她建立了一个总账协议，并规定用比特币来交易。条约为：当对方给Alice的地址提供了狗狗币支付证明(payment proof)，协议会把比特币给到对方指定的地址。 价值盲区限制指Bob作为另一方，必须交易Alice在协议里实际指定的数额。对方可能希望一个较小的交易量，然后得到总账协议里相应部分的资金。这一操作在单比特币总账协议中无法进行。 假设部分交易可行，比特币总账协议必须存储能使用的支付凭证。当这一存储流失，对方能重复提供同样的凭证，不公平地提尽资金。无法存储和价值盲区限制了去中心化交易等程序。 目前的例子仅为了强调限制。它有其他未被提及的瑕疵。去中心化交易比特币在另一个结构——原子交叉链交易(Atomic Cross Chain Trrade)中，可以更好地实施。尽管它也有价值盲区限制。 下一个小节强调的是简介的以太坊方式，为此中描述的协议奠定了基础。 含有以太坊的总账合约以太坊项目含有许多创新，其中以下几个对本文很重要： a. 总账协议是有价值意识(value-aware)，拥有持久存储能力。b. 总账协议在需要的时候能存入/提取(loaded/unloaded)资金。存入/提取条件由协议代码(contract code)执行。c. 有数据的消息可以传送到总账协议。协议能用数据回复，把价值传到输入处。 7小节对以上的使用进行了演示。因此此处举例省略。其他以太坊创新对我们的讨论是次要的，将在12小节提到 a. 总账协议能进入一些随机数据。目的是为投机应用提供熵源(entropy source)b. 用来创立总账协议的改编语言是图灵机完成的。c. 总账协议能创立另一个总账协议。因此，与外部人控制账户有同样的权限。这是指“联系第一阶级市民的财富”(contract first class citizen property) b，c两点的连结意味着在升级以太坊总账时可能会产生无限循环情况(loops)。在估计任意脚本在有限时间内终止或者阻止网络节点拒绝交易导致无限循环时，Halting问题提供了一个限制。当一个程序为了防止节点拒接交易而陷入死循环时，Halting问题对此进行判断之后创新引发的风险有两个： 阻止无限循环的交易费用法在某些未知情况下是有缺陷的。明确设计的恶意协议代码能从以太坊虚拟机中逃逸并引发网络节点损坏。 12小节讨论了防范风险的方式，同时还能得到以太坊的若干好处。驱动力是在邀约实施孵化期避免风险和复杂性。 6-10小节假设以太坊总账协议能力的完整集是有效的。 总账层总账层是用一个允许单一或一组对手方得以建立总账同时流出需求资产的协议来创造的。每一个总账都有个资产发行人，一群总账身份证明和资产发行的身份证明。总账的最低准则为： 每个总账的资产发行人为了维护总账必须是不同实体(entities)。总账是由一个去中心化的共识过程(consensus process)来维护的。参与共识过程的节点集被称为共识池。总账账户余额(balance)，协议和交易是公开的。交易由数字签名的使用来初始创立。多重签名账户是个基本的需求。基础的总账协议能力在每个总账中都是需要的。最小能力集会在12小节详细描述。快速的总账交易最好在两秒内完成全部的确认。当共识池节点身份已知，这对于去中心化总账是可以完成的。我们假设随后阐述也是同样情况。共识池和联合总账会有一次对准机制。 11小节提供了上述特性的理由。超总账确立了通过实际拜占庭容错（Practical Byzantine Fault Tolerance）共识算法来维护总账，同时，也是总账层协议的一个例子。 比特币和以太坊项目假设网络节点是匿名的。这里，我们假设共识池节点的身份(identify)是可知的。这是与其他加密货币项目的主要分歧(divergence)之一。除此之外，聚焦是筹谋金融系统与商品保障货币，像比特币这样的信息化商品，股权和其他资产的相互协调。最终，邀约的系统并不一定要创造任何新的货币或者资产。 图片六显示了总账层(ledger layer)的部分。有同样财产种类的总账有一样的颜色。彩色圆内的黑点代表一个账户。账户对应的资产发行人是已知的。发行人的名字选来方便形象化。大银行和企业，自然又适当的保守的代笔，并非是此处描述的科技的首批客人。 如果carol在总账4里有财产，我们假设她与总账4发行人间有可信任的关系。 在Alice的案例中，她在总账1里有美元，想要把美元转给Bob，一个有相同总账相同发行人客人，也就是说，总账内转账是处理起来比较简单的。下一个小节会介绍总账内转账。 支付和交易层这一层被分配解决Alice和Bob案例中的两种情况： 情况1：Alice有花旗银行发行在总账1里的V美元，她想要兑成总账2的Bob手里的W欧元。Fidor银行是欧元发行人。7a描述了这个情况。情况2：Alice有花旗银行在总账1里发行的V美元，想要支付给Bob。Bob是富国银行总账2的客人。7b，7c和7d展示了决议。这层在开展四个协议（protocols）中的一个起作用。7a和DEP有关，7b和SL3P有关，7c和RTGSP有关，7d和DNSP有关。微交易支付(micro-transaction payments)在附录A中可以参考。 7a.DEP 去中心化交易可以作为两个调停交易关系的连锁总账协议来实施。在图7a，7b，7c和7d中提供了可视情况。为了方便，我们把两个协议命名为发布协议(dispensing contract)以及接受协议(accepting contract)。协议有四个阶段，假设Alice创立了一份Bob接受作为交易方的邀约： 阶段一：Alice在两个总账建立发布协议以及接受协议 图7a代表阶段一Alice在总账2建立接受协议，在总账1建立发布协议发布以及接受协议的连结构成了Alice交易邀约(offer)。定价信息被设定为两个协议的存储入口。Alice负担价值V的发布协议接受以及发布协议的内容见下图 p5 阶段二：Bob相信接受协议，然后问发布协议要钱 图7b形象化了阶段二Bob确认发布及接受协议构成了一个可接受的邀约并且架构正确。接受协议保存资金的状态是Alice需要阶段三c的声明消息来提取它们。Bob提供目前阶段在总账1的发布协议的支付凭证 p6 阶段三：发布协议给Bob放款并给Alice声明消息 图片7c画出了阶段三的情况发布协议确认支付凭证同时确保凭证之前未被使用。完成后给总账1的Bob转V，并为协议内存添加支付凭证。发布协议给总账1的Alice发送提现消息(claim message)。在Alice方便或者立刻就能在接收协议提款 p7 阶段四：Alice用声明消息从接收协议里提款 图7d代表了阶段四Alice在接收协议里施加声明消息接收协议核实声明消息，同时确保声明消息之前未被使用。如果声明消息有效，接收协议给Alice在总账2放款，同时在存储(storage)中添加声明消息的数据。 p8 接收与发布协议的能力 发布协议必须在第三方持有V，同时能够验证总账2的支付凭证。为防止重复使用，使用信息需要被存储。接收协议必须在第三方放置W，同时能够验证总账1的声明消息。为了防止重复使用，用过的声明消息需要被写入合同内存。 上述流程假设交易是自动的，也就是说，发布协议里的V仅在一个交易里被声明。如果Bob在阶段二中想要把交易额改成小于W的X也是可以的。 此外，还有两个要考虑的边缘情况： 1.发布协议未余额：因为对阶段二中把资产转到接受协议时参与方人数没有限制，因此可能发生Bob在要钱的时候没有达到发布协议余额条件。为了防止Bob的损失，需要加入一个额外的功能，给Bob在总账1发送消息“交易被拒”Bob可以用拒信在总账2提款。Alice不会受到拒信，因此她不能解锁总账2里面的资产。2.Alice取消命令：Alice必须拥有提取和添加发布协议资金的能力，同时也能撤销命令。这一能力不能接入之前提起的交易流程。提款引发的非余额能用之前说起的拒信来处理。尽管DEP不可靠又是P2P的，但是信息服务商追踪不同总账的交易命令依然有市场。服务商可以让共识池节点提供命令，核实总账协议合理。参与方会给服务商酬劳来获得更新的信息。纯信息化服务是与命令相当的货币互联网。 DEP的强大在于它消除不同对手方间的对调停货币，股权交易的需要，图8a展示了对手方以及Alice与Bob间有股权交易时的关系。图8b，SEP与8a进行了对比，强调了潜在低成本的交易。一个相似平行情况在货币交易时存在。 中央存管处和保管处的作用被公共加密总账替代。经纪人和股票交易被跟踪总账命令的信息服务所代替。当Alice和Bob对对方风险无法容忍是，清算所就不被需要。协议执行只花了Bob4秒时间。 p9 最终，DEP像一座联系货币和信息化商品，例如以太和比特币，的桥梁。 7b.SL3P 不像去中心化交易那样是目前系统的发展性进步，SL3P是一个新的支付过程。 想象图9a的情况，Alice有花旗银行发布的在总账1上的V美元，她想要把这些钱给Bob。Bob是国富银行在总账2的客人。又有一个叫Carol的，与Alice和Bob有关的对手方，它在两个总账都保持余额。Carol： 相信花旗银行和国富银行两个发行方。对两个总账的各自余额保持中立，只要总量保持恒定。在国富银行持有超过V美元的资产不需要立刻做两个总账之间的交易，也就是说，她的余额是静态现金流(static liquidity)的 p10 根据交易集，图9b描述的协议，解决了支付： Alice在总账1给Carol V美元Carol在总账2给Bob V美元 p11 SL3P利用两个总账协议来保证多重需要满足交易逻辑的特性： Alice发给Carol的总账协议确保她在总账2支付Bob，或者她在总账1收回她的钱。总账协议可以保持，也就是说，Carol构造一次协议，然后协议自动在不同对手方进行支付。Carol为了保证静态现金流动性可以在支付时候收费。协议需要四个阶段： 阶段一：Carol通过创立在两个总账的协议开了个SL3P通道(channel)。 图10a代表阶段1Carol在总账1创立SL3P协议1，在总账2创立SL3P协议2。对称的SL3P协议1以及SL3P协议2的连结叫做SL3P通道。协议存储了作为数据入口的每次交易收费情况。Carol现在值X的协议1以及值Y的协议2SL3P协议的能力如下 p12 阶段二：Alice相信SL3P协议1，在SL3P协议2问Bob要钱 图10b显示了阶段二Alice想支付给Bob V，同时核实SL3P协议2拥有一个超过V的余额（balance）。若是，她进入下一步Alice把V美元转到SL3P协议1SL3P协议1以特殊状态持有资金。这些资金只有在阶段四后才能被提出来，或者SL3P协议2在阶段三d不给Bob钱Alice为上述情况提供证明给了SL3P协议2，并且创立一个给Bob总账2的账户的转账。 p13 阶段三：SL3P协议2核实声明，给Bob打钱 图10c描述了阶段三SL3P协议2核实支付凭证然后检查了它之前是否有被用过。核实无误后，它给Bob转账V，给Carol在总账2发状态改变消息。支付证明数据添加在协议存储中。Carol能用状态改变消息来把SL3P协议1里的资金存在阶段二c，她随时可提。如果余额不满足，协议在总账2发送“拒绝支付”消息给Alice。Alice能用就行从SL3P协议1提钱。Bob在协议里只需要核实成功转账 p14 阶段四：Carol用状态消息提钱 Carol从之前的SL3P协议1里拿出状态改变消息SL3P协议1核实状态改变消息，把消息存在之前重复使用的记忆里，然后使得V之后可以被Carol提出。只有Carol之后能在SL3P提出来的钱参与了。Carol能把阶段三委托给第三方。第三方监管SL3P协议然后确保他们能够在静态现金流动性中有足够的参与。 p15 SL3P协议的能力 SL3P协议需要在第三方保持余额，同时能够核实支付凭证，状态变更消息。已经使用的凭证和学校需要被保存在记忆存储中来防止重复使用。在发生不余额状态时的SL3P支付，目标协议必须发布一个“支付被拒”消息给创立者。支付被拒消息能让另一个协议能提出款项。SL3P协议必须允许Carol在没有违背协议条件是存取款。Carol手里两个协议都达到余额，钱全部被提出来了，通道也就结束了。 协议逆袭也可行。因为SL3P协议是对称的，Dave能够创立一个支付，从总账2到总账1. 支付过程被修改成了P2P模式，为竞争市场提供基础。协议是两次转账协议计算的连结，因此能在4秒内完成。 国内相应的银行能被可视化成Carol，作为两个接入发行人之一。比如，假设总账1的发行人是发行人1,。如果发行人 、1在SL3P渠道总账2开设存款，导致的是一个与之对应的国内银行的关系。读者应该能够记住国内相应银行正不断加速对时代错误的解决。 SL3P提升了递延净结算（Deferred Net Settlements）因为发行者没有假设支付过程中的信任风险。为了减缓递延净结算中的信任风险，发行者需要给清算所抵押。SL3P提出没有这个必要性。 另一个关键优势是创立新的支付过程流动性池。流动性成本是给RTGS支付定价的决定性因素。一个目前系统中的核心假设是支付过程中的流动性需求是由发布者提供的。SL3P能够打破这个假设，建立一个更大的流动性池，也因此得到更实惠的支付。 7C。即时支付结算协议（RTGSP） 与SL3P相似，RTGSP解决了这一问题：Alice拥有花旗银行在总账1里的V美元，想要把这些钱转给Bob。Bob是国富银行在总账2的客人。 RTGSP和美国用来进行高价值(high value)转账的FedWire系统的邀约共识。它允许涉及到的发布人在内部银行从FR总账支付设置负债账户。图11展示了FedWire交易流程。 Alice创立了一个FedWire贷款，其中花旗银行作为OFI，国富银行作为RFI。花旗银行立刻把Alice的账户计入借方，国富银行几分钟后确认Bob的账户。 内部来看，花旗银行向FR提交了一份授信需求，需求之后给到了国富银行。FR进行结算交易，把钱在FR总账上从花旗银行转到国富银行。当交易实际开展的时候，结算总数额被转账，这一形式的支付过程被称为实时全额结算（RTGS）。分别假设花旗银行和国富银行不存在授信风险。 沿着这一点继续拓展，我们把花旗银行看作发行者1，国富银行看作发行者2.目标是展示一个把花旗，国富以及FR作为加密总账的协议。 p16 SL3P提供了一个在图12里描述的路径。发行者开设了单向的，在FR总账和追踪财产总账之间的SL3P通道。一个发布者2维护的SL3P通道在图12里显示。在总账2中，发布者2创立了在通道一端(one end of the channel)的资产和负债。用深粉红色标记。 单向SL3P通道指的是支付方向是单向的改进结构。在小节7b中，这是一个简单的修缮。 Alice创立了转账V给发布者1的交易。交易包含说明最终总账的数据和Bob的账户。这有效地打击了Alice持有，发布者1 发布的财产。 假设花旗银行有必须的流动性，它把V转账到FR总账的发布者2 维护的SL3P协议。接着，它把支付凭证给到总账2的另一方，并且把转账给到Bob的账户。 假设有足够的协议余额，总账2 SL3P协议核实支付凭证完成了转账。发布者2阶段性地把资金下载到协议来保持RTGSP转账流通。当协议余额没有达到，发布者1能重新尝试或者从通道(channel)另一端要回财产。 p17 尽管目前证明RTGSP是可行的，可没有涉及RTGS系统的核心挑战：流动性管理。附录B会涉及到这个问题。 RTGSP能够确保FedWire和其他全额清算系统的自动化。FR的作用被限制用来作为单纯的发布者。只要FR总账共识池可以达到，系统就能够运行。目前，美国FedWire系统的作用被限于09:00到18:00 ET。 FR总账的去中心化和RTGS系统可以作为一个优质的运行风险控制和商务持久性政策。节点可以地理意义上去中心化，使得不同动能系统相互独立，建立数据备份。总的来说，所有系统性重要的支付系统很明显地从运营风险控制带来的去中心化化获利。 7D。递延净额结算协议（DNSP） DNSP和SL3P以及RTGSP解决同样的问题：Alice有花旗银行在总账1里的V美元，她想把钱转给Bob。Bob是国富银行在总账2的客人。 取代支付清算，像RTGSP一样，结算作为FR总账的转账；DNSP最终创立了一个花旗对国富的债务。多重债务可以聚合。只要双方同意FR总账，净量会在发布者之间转账。支付清算是发布者之间关于债务关系所创立的，同时支付关系式在FR总账上进行转账。DNSP把支付推迟到了支付清算后。协议需要发布者之间相互信任。 DEP,SL3P和RTGSP的连结能应对一大部分的银行交易。DNSP因为完整性被涵盖。它等同于美国的ACH系统。 由Ryan Fugger和Ripple项目领衔的横向交易(traversal transactions)构建了DNSP的中心。一个横向总账，使得横向交易拥有除了至今想到的以有特性： 账户能够建立与其他账户的可信联系。一个可信联系是账户持有者在共识池中的批准，允许池依照价值和对手方(party)在信任联系里的规定改变账户余额。共识池可以把一个账户对另一个的支付改成其他账户的余额，受限于信任联系定下的约束。 图13介绍了一个美元横向总账，有四个参与者：Eve, Frank, Gary和Harry。图13a的左侧展示了信任联系情况。一根线从frank到eve，价值M美元。表示frank同意eve欠它不超过M美元。参与者能动态改变信任联系。 图13b右边展示了eve和Harry之间W美元的横向交易支付。在支付之前，我们假设没有一根参与者彼此有债务关系。交易之后，eve欠frank W美元，frank欠Gary W美元，Gary欠Harry W美元。哈人有接受这W美元的支付。 每个账户的净余额等于参与者持有的债权减去持有的债务。交易后Frank和Gary的净余额保持不变。Gary和frank没有积极参与交易。Harry的作用是核实支付情况。 因为总账也许会有更多参与者；共识池技术最优支付路径，由13b的红色箭头表述，同时自动调节余额。 p18 对于DNSP，我们假设多位发布者作为国内横向总账的一部分。横向总账变为支付清算机制，信任联系有两位发布者协商而定。DNSP有两个阶段，在图14a和14b表述。 阶段一：Alice创立支付，发布者1给发布者2财产 发布者在总账上创立一个第三方合同，追踪财产，给合同下载财产。第三方合同的能力之后会解释。Alice V在总账1上把财富转给发布者1。交易包含最终总账和Bob的元数据地址。发布者1和发布者2在国内清算总账做一笔价值W的横向交易。W小于V，在0-5美元之间。发布者1把上述的支付证明给到总账2的第三方协议，要求协议给出V第三方协议核实支付凭证，下一步假设证明无误如果有超过V的资金，它在T时刻转V。在0到T时刻之间，当发布者1完成阶段二，V仅能被转给Bob。T大概是一分钟。如果协议没有完成转钱的资金，它把W转给Bob，给发布者2发送“预约被拒”的消息。 p19 阶段二：发布者1把财产（V-W）转到清算总账，要求Bob进行支付 假设预约成功，发布者1在清算账户转钱（V-W）给发布者2发布者1把上述支付凭证给到总账2的第三方协议，问Bob要V第三方协议核实支付凭证，如果无误，把留存资金转给总账2的Bob。当发布者1不能在时间T内完成阶段二，发布者1可以要求给Bob W的转账。第三方在这种情况下可以发动一个罚金X （X&lt;W） p20 在目前的状态下，DNSP有一个缺陷。在阶段一，第三方协议也许被耗尽然后资产小于W。这会导致发布者1承受W的损失。因为如下原因，这个缺陷可以容忍： 面临风险的资产数额低。W大概是5美元，相较于实体支付系统是个小数额。如果第三方协议耗尽，所有在总账2的DNSP支付会停止，因为总账2是公共的，问题会升级。发布者2的声誉会在DNSP关闭的期间受损。 发布者之间撇除DNSP的债务关系是在双方同意后建立在FR总账上的。清算在FR总账上只是两个发布者之间的简单转账，因此不被注解。DNSP区分了清算和结算过程，导致给Bob的快速转账（少于10秒）。许多现在的系统，像是美国的ACH和英国的Bacs，清算和结算转账每天只有一次。因此DNSP能够做到一个提升。此外，清算总账里的信任联系设计移除了目前的两层布置的中心控制成员系统。任何发布者只要保证在与另外发布者的信任联系里能够参与清算。对于对称的系统重要支付系统，去中心化清算总账减少了营业风险，是商业持续连续性的方式。 联合之前的小节对协议的每个特征着重解释了一下，在实现上略令人沮丧。这些明显的负责性是源于实际系统中的相互作用，同样能简化到实现时一个简单优雅的层面。 一个关键的观察是利用了DEP和RTGSP的总账协议是SL3P的衍生。图15表达了这个结论。p21 对于上述论述，也许挑战在于把发布与接收协议是SL3P协议的衍生可视化。请参考7b，把Alice换成Carol；Alice和Bob换成Bob。此外，取而代之总账只处理单一货币，它们那个处理不同货币。这些取代之后的交易流程是货币交易。 我们可以停止参考不同名字的协议，尽管作者信息信息这有助于区分。 拓展（pathfinding）层面在拓展层面，之前描述的协议被自动看成5类： 两个账号直接的财产转移。假设执行时间小于2秒。两个通过DEP追踪不同或相同资产种类的总账。假设执行时间小于4秒。两个通过SL3P追踪相同种类货币的总账。假设执行时间小于4秒。两个通过RTGSP追踪相同种类货币的总账。假设执行时间小于6秒。两个通过DNSP追踪相同种类货币的总账。假设执行时间小于10秒。 任何源于一个加密总账结束与另一个总账的全球支付，汇款，资产购置或交易能分成上述所说的5类自动运营。拓展层面的任务是结算最优自动运营集来执行需要的财产转账或交易。 小的世界网络相识社交网络，通过短距离双节点连接。我们假设，没有证明，货币的金融互联网也是一个小世界网络。实际上，这意味着任何全球财产转账/交易能在最长不超过5-7自动运营下执行。一分钟的 全球最长转账世界看起来在这样的连接下可以接受。 拓展算法的原始数据有以下几种： 不同总账上有的即时DEP数据库一组在总账之间运营的SL3P通道一组全球承认的RTGSP网络若干组参与RTGSP网络的发布者一组全球公认的DNSP网络让观众参与DNSP网络的发布者执行自动步骤的，成本功能数据的金钱成本 互联网上类似的挑战层面有途径协议，例如RIP, OSPF和BGP。通过互联网的交流路径需要路由器和节点不断广播可达信息。作为一个跨多路由/节点的拟分布算法是可视的。 在货币的互联网，集中的服务中路径需求可以被发送，收到的最优路径合理。数据的收集和计算外包给这些服务商来减轻客户的工作量。实际的计算最优路劲算法将留到日后的文章来讨论。 一旦客户得到了最优路径，路径执行全球价值转移和交易的自动运营。 图15展示了拓展情况。Alice在美国总账上有瑞士法郎资产，她想要买苹果的股权。她发起了一个对拓展服务器的路径需求。拓展服务器有一个RTGSP网络的数据库，DNSP网络和不同总账的协议。它评估了3个可选路径，包括Alice可以拿的数量。它指出了Alice的最优路径和解释了支付和交易费用。 Alice的客户有一个协议软件来执行需要自动运营的行动。她如是操作也得到了想要的股权。 p21 协议层 协议层使得交叉价值和任意编代码运行来改变值余额。可以通过实现codius和gavin andresen的可编程的仲裁（programmable orcles）项目来实现。 协议层的优势项是让低级层作为单一(singular)全球总账。这一抽象总账可以保持余额，一分钟内转移财产。 由一组特殊的实体所控制的，替智能协议的资金成为了N中M个多重签名的账户。协议代码是同时发送给各个实体的。每次协议机构想要给合同发送一个消息，他们把消息给到仲裁(oracles)里。仲裁跑代码来计算参与者的余额。如果编码导致才协议提款给某个指定地址的执行操作，则仲裁循环交易转移资金并且签名。资金转移由货币的互联网较低层来处理。图17展示了这一协议层。 p23 12小节量化了总账协议与协议层之间的差异。总的来说，总账协议用来构建支付和交易协议。其他使用案例智能协议在协议层实施。 举个例子，伦敦布鲁特有一份Alice和Bob之间的原油期货协议。协议由电脑编码表示，仲裁执行；执行实体取回外部数据为Alice和Bob在结算的时候计算新的余额。在编码执行后，再次通过较低的货币互联网层达到Alice和Bob之间的余额。 另外一个例子是专业买家卖家的调停，在图四中可见。Alice是买家，Bob是卖家。他们想要依照成功交付的时间来定义支付数额。Bob在长期交付的情况下会要付罚金。协议建立后Alice出款。协议的服务核实货物的交付，依此付钱给了Bob。 第三个例子是数字资产竞拍。建立协议来实行竞拍的规则。如果数字资产主交付给了项目仲裁，规则执行。 应用层 和TCP-IP协议组相似，这一层包含应用和用户间交流。特别地，一下内容在商业上尤其重要。 借方和贷款为基础的支付网络尽管货币互联网被预见，同时在全球范围内提升价值转移速度的数量级，一些使用案例需要支付网络，例如Visa和Mastercard。有下述案例： 转移认证需要猝发，例如商店购买情况。多重自动转移和交易的操作需求使得自有秘钥必须被多次使用。一个支付网络会要有额外的安全性。支付网络促进买卖双方的仲裁。通过支付网络可以有效减少结算风险。它通过技术减短了支付以及交易时间。Visa在2013年九月三十日结算数额被爆为五千三百八十万美元。 最终，协议层能让一些例如双保证金托管（double deposit escrow）的新仲裁方法可行。 期货，期权，衍生品，预测(prediction)和其他市场作这篇文章的核心理念之一是分类原则：每个货币互联网的特性都是有不同实体来运作的。例如，共识池是由总账维护从事，银行做资产发行与合规的工作，拓展服务由拓展来做，其他企业做协议应用。 协议和应用层确保了期货，期权，衍生品，仲裁市场的发展。不同的服务能细分市场。 Hazard关于智能协议的游戏作为示例，这个游戏可以看作有以下规则的协议： Roulette轮的旋转是模范熵源以广义熵的输入作为参与者余额的改变。价值的专移与交易通过较低货币互联网层来进行我们宣称，没有证明，hazard所以游戏包括扑克，二十一点都是以智能协议来实施的。 去中心化应用抽象总账是简历去中心化应用的有力基石。目前依照的方式有在接触服务时构建新的代笔，例如去中心化存储，多跳网络（mesh network）和信誉体系。货币互联网提供了构建代币的方式。例如。一个分享硬盘空间的DApp在附录C里提及. 再看总账层 这一小节会通过思考一些问题来获取对总账层最少需求的更优理解（小节6）： 为什么总账不能被开发者控制？ 支付和交易协议构建时让开发者以外的实体来执行总账上的交易。例如RTGSP：发布者1给Bob在总账上发送支付，发布者2不参与。现在假设发布者2的服务器是共识池里维护总账2的唯一节点。 以上情况发布者2可以建立一个新的总账历史记录，与过去的记录不共识，声称发布者1从未完成给Bob的支付。如果Alice和发布者1无法获取旧有历史记录时间，就无法很好地讨论新的历史。争论时法务成本会比预期规定的大。 假设的解决方式是有多重对手方通过去中心化的共识过程来维护总账。通过去中心化化，发布者和顾客能确保总账的公平。因此： 去中心化化服务能提高总账公平信心。共识池里参与的节点越多元，对公平的保证越强。 权衡内在的去中心化是有效的。节点需要去相互证明它们的过程并且交流来达到共识。这博士宽带和计算更优于相同的集中总账。 为了去中心化而去中心化博士一个提倡的策略。本文的观点是： 某个使用案例的去中心化化程度需求是个求最优的问题 影响有效性的因素，定义为交易处理过的投资节点中每个NPV美元是： 共识过程的选择节点身份假设。有效性在节点身份已知的时候戏剧性地增加。比特币节点是匿名的，网络会蒙受高额成本，0-5亿美元每年来保持共识。节点数额。总的来说，共识池越大，有效性越低。 影响总账公平相信的因素： 共识池的构成。当例如谷歌这样有信誉的公司在池子里有节点，它会推动池子的信心。谷歌所有节点的恶意行为会有损它的市场信誉。存亡危急时谷歌的商誉可能价值百万美元。共识过程的选择。比如，实际拜占庭容错能容下池子里最多33%的恶意节点。共识池里控制节点的不同实体数额。数额越高，越可信。 总账信誉的信誉额依据风险时的价值。提倡的策略是： 目标是保持资产处于风险或总账有效可信之间的余额。 例如，越高同质池也许能追踪两个杂货连锁店的忠实点数。花旗银行总账会因高信任/去中心化化获益。 最优总账层协议 因为每个使用案例有不同的最优池组成和节点数，总账层协议需要十分灵活。对协议的用法，开发性和发展没有限。共识过程应该在跨部情况下有最好的有效性。 超总账项目是这个方向的先驱。充满希望地，其他系统目标的项目在跟进。 为什么总账要是公开的？ 所有这里所说的支付和交易协议都是基于公开总账的。另一方不能在私人总账上查看邀约或核实支付。 如果应用假设有价值，均衡化隐私增强了需要发展的科技。类似地，支付需要监控金融交易的方式。当保障金融隐私的成本不超过客户从例如去中心化交易等应用中的获利时，货币互联网的投资可以被看见。 介于隐私问题被解决了，作者对潜在全球交易数据获取公开带来的经济理论和危机管理的提升表示激动。 关于多重签名账户 多重签名账户除了增强了客户安全，协议层同样需要值得信任的执行。智能协议需要被核实，同时由多重有区别的项目仲裁来执行仲裁池需要为日常运营获得连结多重签名账户。 关于共识池的时间排列机制 时间排列机制为池节点时间校准提供了方法。好的设计源于建立有效的最小组成。这篇论文为DNSP和MTXP(附录A中)利用时间基础交易。去除时间排列机制还保存功能的方式还需要去发现. 降低萌芽阶段的风险和复杂性 意见和开放性问题 加密总账的基本优势 本文假设了加密协议的构建利用了加密总账，从而使得建立了参与的发布者和客人之间低信任的金融关系。低信任关系能减少交易成本，对于客人来说是一个净收入。 扩展性分析和基于拉取的支付 电子签名的使用使得所有加密总账系统成为基于推送的。目前ACH的实施使得基于拉取的ACH借方能够实行，它有多重例如保险支付，贷款分期偿还和公共设施支付等应用。 这些应用能建立在协议/应用层是依靠一个机制的。当Alice作为Bob的一个客人是，有一个一个公用事业单位。Alice和Bob建立一个由互相信任的仲裁持有的智能协议。Alice给合同注入款项作为月度使用支付。协议包含让Bob每月提款的条约。 身份认证和匿名层的实施 顺从规则从而还产生了一个问题：公共秘钥后的身份必须能让某个组织（例如发行方）联系到从而抵制一些例如污点分析的问题。有个核实发行方和总账的方法同样是首要条件。 Referencehttps://bitcoin.org/bitcoin.pdfhttps://en.bitcoin.it/wiki/Script页20-28，在TCP-IP协议栈，4 日 版，贝洛兹A. Forouzanhttp://hyperledger.com/https://www.regaltek.com/docs/understanding-ach-network.pdfhttps://github.com/TierNolan/bips/blob/bip4x/bip-atom.mediawikihttps://github.com/petertodd/bips/blob/checklocktimeverify/bip-checklocktimeverify.mediawikihttp://gendal.wordpress.com/2014/01/05/a-simple-explanation-of-how-shares-move-around-the-securities-settlement-system/页323-374，在TCP-IP协议栈，4 日 版，贝洛兹A. Forouzanhttps://github.com/codius/codius/wiki/Smart-Oracles:-A-Simple,-Powerful-Approach-to-Smart-Contractshttp://gavintech.blogspot.ch/2014/06/bit-thereum.htmlhttp://www.sec.gov/Archives/edgar/data/1403161/000140316113000011/R19.htmhttp://bithalo.org/wp-content/uploads/2014/06/whitepaper_twosided.pdfhttps://www.ethereum.org/pdfs/EthereumWhitePaper.pdf 关于作者作者Meher Roy 联系方式： 电子邮件1：meher.roychowdhury@gmail.com 电子邮件2：mr@hyperledger.com LinkedIn：https://www.linkedin.com/pub/meher-roy/43/969/254 微博：https://twitter.com/MeherRoy 特别感谢Tim对马卡里奥斯指出错误，并建议有关负责穿越交易协议。 0.4版本可能的更新 对准Hyperledger白皮书 Hyperledger是一个总账层协议的最好例子，目标是一对2兼容的文件（Hyperledger白皮书+当前文档）。 考虑负责任的穿越交易协议作为一个更好的DNSP 引用参考： http://ideophilus.wordpress.com/2014/11/05/a-responsible-transitive-transactions-protocol/ 附录A，B和C的完成 附录A：微交易协议（MTXP） 附录B：方法RTGSP流动性管理 附录C：分权应用体系架构（DApps） 感谢维优提供的翻译]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>区块链 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比特币(bitcoin)自私挖矿与拜占庭将军问题]]></title>
    <url>%2Farchives%2F02-bitcoin-and-byzantine-issue.html</url>
    <content type="text"><![CDATA[这是一篇译文转载。 每次我向那些不熟悉比特币的人解释比特币的独特之处的时候，我都会用会计学上的总账和拜占庭将军问题来帮助讲解。此文就是帮助讲解的内容，有Q了此文我就可以把链接发给小伙伴们，而不需要每次都重新打一大堆字了。 首先，不要把比特币当成一种货币，而是一个总账。它是个电子总账，网络上的每一个参与者的电脑都会有一份总账的备份，并且所有的备份都是在实时的持续的更新、对账、以及同步着。每一个参与者都能在这本总帐里记上一笔，这一笔记录着一定数量的币从一个参与者那里被发送到另一个参与者那里，并且每一条这样的记录都接着就实时的广播到网络了，所以在每一台电脑上的每一分份拷贝都是几乎同时更新的，并且所有的总账拷贝都保持着同步。这本公开的分布式的总账的官方叫法是“区块链（blockchain）”，并且它使用了BT技术以保证所有的拷贝都是同步的。 你还可以把比特币当作一个对于在分布式系统领域的一个复杂的算法难题的通用解决方法，这个难题俗称“拜占庭容错”、“拜占庭将军问题”、或者“两军问题”。 这一问题的趣味非正式表述如下：想象一下，在拜占庭时代有一个墙高壁厚的城邦，拜占庭，高墙之内是它的邻居想象不到之多的财富。它被其他10个城邦所环绕，这10个城邦也很富饶，但和拜占庭相比就微不足道了。它的十个邻居都觊觎拜占庭的财富，并希望侵略并占领它。 但是，拜占庭的防御是如此的强大，没有一个相邻的城邦能够成功入侵。任何单个城邦的入侵行动都会失败，而入侵者的军队也会被歼灭，使得其自身容易遭到其他九个城邦的入侵和劫掠。这十个城邦之间也互相觊觎对方的财富并持续互相对抗着。而且，拜占庭的防御如此之强，十个邻居的一半以上同时进攻才能攻破它。 也就是说，如果六个或者更多的相邻敌军一起进攻，他们就会成功并获得拜占庭的财富。然而，如果其中有一个或者更多背叛了其他人，答应一起入侵但在其他人进攻的时候又不干了，也就导致只有五支或者更少的军队在同时进攻，那么所有的进攻军队都会被歼灭，并随后被其他的（包括背叛他们的那（几）个）邻居所劫掠。这是一个由不互相信任的各方构成的网络，但他们又必须一起努力以完成共同的使命。 而且，是个邻居之间通讯和协调统计时间的唯一途径是通过骑马在他们之间传递信息。他们不能聚在一个地方开个会（所有的王都不互相信任他们的安全在自己的城堡或者军队范围之外能够得到保障）。然而，他们可以在任意时间以任意频率派出任意数量的信使到任意的对方。每条信息都包含类似如下的内容：“我将在第四天的6点钟进攻，你愿意加入吗？”。 这是一篇译文转载。 每次我向那些不熟悉比特币的人解释比特币的独特之处的时候，我都会用会计学上的总账和拜占庭将军问题来帮助讲解。此文就是帮助讲解的内容，有Q了此文我就可以把链接发给小伙伴们，而不需要每次都重新打一大堆字了。 首先，不要把比特币当成一种货币，而是一个总账。它是个电子总账，网络上的每一个参与者的电脑都会有一份总账的备份，并且所有的备份都是在实时的持续的更新、对账、以及同步着。每一个参与者都能在这本总帐里记上一笔，这一笔记录着一定数量的币从一个参与者那里被发送到另一个参与者那里，并且每一条这样的记录都接着就实时的广播到网络了，所以在每一台电脑上的每一分份拷贝都是几乎同时更新的，并且所有的总账拷贝都保持着同步。这本公开的分布式的总账的官方叫法是“区块链（blockchain）”，并且它使用了BT技术以保证所有的拷贝都是同步的。 你还可以把比特币当作一个对于在分布式系统领域的一个复杂的算法难题的通用解决方法，这个难题俗称“拜占庭容错”、“拜占庭将军问题”、或者“两军问题”。 这一问题的趣味非正式表述如下：想象一下，在拜占庭时代有一个墙高壁厚的城邦，拜占庭，高墙之内是它的邻居想象不到之多的财富。它被其他10个城邦所环绕，这10个城邦也很富饶，但和拜占庭相比就微不足道了。它的十个邻居都觊觎拜占庭的财富，并希望侵略并占领它。 但是，拜占庭的防御是如此的强大，没有一个相邻的城邦能够成功入侵。任何单个城邦的入侵行动都会失败，而入侵者的军队也会被歼灭，使得其自身容易遭到其他九个城邦的入侵和劫掠。这十个城邦之间也互相觊觎对方的财富并持续互相对抗着。而且，拜占庭的防御如此之强，十个邻居的一半以上同时进攻才能攻破它。 也就是说，如果六个或者更多的相邻敌军一起进攻，他们就会成功并获得拜占庭的财富。然而，如果其中有一个或者更多背叛了其他人，答应一起入侵但在其他人进攻的时候又不干了，也就导致只有五支或者更少的军队在同时进攻，那么所有的进攻军队都会被歼灭，并随后被其他的（包括背叛他们的那（几）个）邻居所劫掠。这是一个由不互相信任的各方构成的网络，但他们又必须一起努力以完成共同的使命。 而且，是个邻居之间通讯和协调统计时间的唯一途径是通过骑马在他们之间传递信息。他们不能聚在一个地方开个会（所有的王都不互相信任他们的安全在自己的城堡或者军队范围之外能够得到保障）。然而，他们可以在任意时间以任意频率派出任意数量的信使到任意的对方。每条信息都包含类似如下的内容：“我将在第四天的6点钟进攻，你愿意加入吗？”。 如果收信人同意了，他们就会在原信上附上一份签名了的/认证了的/盖了图章的/验证了的回应，然后把新合并了的信息的拷贝再次发送给九个邻居，要求他们也如此这样做。最后的目标是，通过在原始信息链上盖上他们所有十个人的图章，让他们在时间上达成共识。最后的结果是，会有一个盖有十个同意同一时间的图章信息链，可能还会有一些被抛弃了的包含部分但不是全部图章的信息链。 但是，问题在于如果每个城邦向其他九个城邦派出一名信使，那么就是十个城邦每个派出了九名信使，也就是在任何一个时间又总计90次的传输，并且每个城市分别收到九个信息，可能每一封都写着不同的进攻时间。除此以外，部分城邦会答应超过一个的攻击时间，故意背叛发起人，所以他们将重新广播超过一条的信息链。这个系统迅速变质成不可信的信息和攻击时间相互矛盾的纠结体。 比特币通过对这个系统做出一个简单的（事后看是简单的）修改解决了这个问题，它为发送信息加入了成本，这降低了信息传递的速率，并加入了一个随机元素以保证在一个时间只有一个城邦可以进行广播。它加入的成本是“工作量证明”，并且它是基于计算一个随机哈希算法的。哈希是一种算法，它唯一做的事情就是获得一些输入然后进行计算，并得到遗传64位的随机数字和字母的字符串，就像这个： d70298566aa2f1a66d892dc31fedce6147b5bf509e28d29627078d9a01a8f86b 在比特币的世界中，输入数据包括了到当前时间点的整个总账（区块链）。并且尽管单个哈希值用现在的计算机可以几乎即时的计算出来，但只有一个前13个字符是0的哈希值结果可以被比特币系统接受成为“工作量证明”。这样一个13个0的哈希值是极其不可能与罕见的，并且在当前需要花费整个比特币网络大约10分钟的时间来找到一个。在一台网络中的机器随机的找到一个有效哈希值之前，上十亿个的无效值会被计算出来，这就是减慢信息传递速率并使得整个系统可用的“工作量证明”。下面是一个例子： f51d0199c4a6d9f6da230b579d850698dff6f695b47d868cc1165c0ce74df5e1 d70298566aa2f1a66d892dc31fedce6147b5bf509e28d29627078d9a01a8f86b 119c506ceaa18a973a5dbcfbf23253bc970114edd1063bd1288fbba468dcb7f8 在找到一个有效值之前，成百万上亿个更多的类似上面这样的字符串被计算出来。。。 000000000000084b6550604bf21ad8a955b945a0f78c3408c5002af3cdcc14f5 那台发现下一个有效哈希值的机器（或者说在我们类比中的城邦），把所有的之前的信息放到一起，附上它自己的，以及它的签名/印章/诸如此类，并向网络中的其他机器广播出去。只要其他网络中的机器接收到并验证通过了这个13个0的哈希值和附着在上面的信息，他们就会停止他们当下的计算，使用新的信息更新他们的总账拷贝，然后把新更新的总账/区块链作为哈希算法的输入，再次开始计算哈希值。哈希计算竞赛从一个新的开始点重新开始。如此这般，网络持续同步着，所有网络上的电脑都使用着同一版本的总账。 与此同时，每一次成功找到有效哈希值以及区块链更新的间隔大概是10分钟（这是故意的，算法难度每两周调整一次以保证网络一直需要花费10分钟来找到一个有效的哈希值）。在那10分钟以内，网络上的参与者发送信息并完成交易，并且因为网络上的每一条机器都是使用同一个总账，所有的这些交易和信息都会进入遍布全网的每一份总账拷贝。当区块链更新并在全网同步之后，所有的在之前的10分钟内进入区块链的交易也被更新并同步了。因此分散的交易记录是在所有的参与者之间进行对账和同步的。 最后，在个人向网络输入一笔交易的时候，他们使用内嵌在比特币客户端的标准公钥加密工具来同时他们的私钥以及接收者的公钥来为这笔交易签名。这对应于拜占庭将军问题中他们用来签名和验证消息时使用的“印章”。因此，哈希计算速率的限制，加上公钥加密，使得一个不可信网络变成了一个可信的网络，使得所有参与者可以在某些事情上达成一致（比如说攻击时间、或者一系列的交易、域名记录、政治投票系统、或者任何其他的需要分布式协议的地方）。 这里是比特币为何如此特别的关键：它代表了一个对于一个困难的算法上的难题的解决方案，这一解决方案在一系列的历史事件发生之前是不可能的，这些事件有： 互联网的创造 公钥加密算法的发明 点对点Bitorrent(BT)协议的发明。BT协议最开始是开发来用于在网络上的相对小的用户子集之间共享许多文件的，但比特币用它来在所有用户之间共享单个文件。 人们意识到，在系统中添加一个简单的时间延迟，同时使用公钥加密算法以验证每笔交易，可以解决这个问题。 如果说一些最棒的想法在事后看来是很简单的，那么上述的第四点就完全符合条件，尽管整个项目是站在了巨人的肩膀上的。 最后，这一对于拜占庭将军问题的解决方案，可以推广到任何核心问题是在分布式网络上缺乏信任的领域。如我们已经提到乐的，人们正在为互联网建设一个分布式的域名系统，以及为政治选举建设分布式的投票系统（还没有网站）。如果人们认为单纯的文件分享搅乱了这个世界，那么比特币解决方案和协议才刚刚打开洪水的闸门。 比特币的规模需要扩大1000倍才能和Visa竞争。我们该怎么做。 比特币的核心组件叫做“区块链Blockchain”，它是一个全球共享式的记录着每一笔曾经发生过的比特币交易的文件。它的名字源自平均每10分钟P2P的比特币网络就会添上一个新的收纳了最近的交易记录的“区块Block”。 这一区块链是参与到一个叫做“挖矿mining”的交易结算过程中的数量巨大的计算机中所共享的。为避免这些计算机过载，比特币软件在目前限制每个区块的最大尺寸在1MB。结果是：目前，比特币网络每秒只能处理大概7笔交易。相较之下，Visa网络的设计目标是可以处理峰值每秒10000笔的交易。 到目前为止，这还不是个大问题，因为比特币用户们现在每秒大概只生成一笔交易。但如果比特币经济持续增长，上面说的那个限制早晚会成为一个麻烦。 比特币网络可以进行修改，以应付将来可能出现的比现在高得多的交易量吗？为了找到问题的答案，我和著名比特币开发者Mike Hearn聊了聊。他帮助我了解了当前比特币系统性能的限制，以及比特币开发团队关于如何解决这些问题的计划。 Timothy B. Lee（作者）: 你可以简单的讲讲一下当前比特币网络对于可以容纳多少笔交易的限制吗？ Mike Hearn: 现在市面上存在着两种比特币客户端：“完全节点”和“轻节点”，后者我们又称作简化支付验证（SPV）节点。轻节点不关心区块的尺寸有多大，而完全节点有个硬性的物理尺寸限制（也就是每个区块最大1MB）。 所以每10分钟1MB，除以每笔交易记录的平均尺寸，我们可以得出当前的限制大概是在每秒7笔交易。 比特币每日交易笔数。现在理论上的限制大概是每天600,000笔交易。 我们现在距离那个限制有多远？ 如果你看过那个每天交易数量的图，就会知道我们当前交易数量的峰值是每日70,000笔。我们现在甚至都还没到每秒一笔交易（也就是每天86,400笔交易）的程度。数值在增长。它增长的很好很快。如果你画出一张整体图的话，就可以看到它有个漂亮的小指数斜率。我们距离那个限制还有相当长的一段距离。因为各种各样的原因，这也说不好。但我们目前完全不用担心容量用完这回事。 如果想要提供超过每秒7笔的处理能力，会有些什么要求？ 我们只需要拿开那个限制，并让人们更新他们的节点就行了。我们还没有做这件事情的原因是，我们还在想办法搞清楚究竟是换一个新的限制还是完全不要加限制好了。如果不加限制的话，我们如何保证没有人会故意制造一个让人们感觉讨厌的臃肿区块。 Gavin（指Gavin Andresen，他是比特币的头号开发者）正在为这个事情做一些准备性的工作。他现在正在改造收费系统。我们的设计目标是在将来不对区块尺寸设任何限制，但默认情况下矿工们将拒绝处理那些大到离谱的区块。 你可以解释一下比特币交易费是如何运作的吗，以及为什么这个系统需要它们？ 在比特币世界里，你可以在任何一笔交易上附上一笔交易费（是指一笔付给处理这笔交易的矿工的报酬）。在最开始比特币还是个新生事物的时候，所有的交易都是免费的，并且随着时间的流逝规则也有所调整，所以你还是可以发送不付费的交易，但它们会的处理速度会比较慢。交易费充当着一个阻止虚假交易泛滥于网络上的限流器。如果每笔交易都是一直免费的，你会看到人们有事没事就把比特币来来回回发送着玩。 现在我们遇到的主要麻烦是，贯穿全网的交易费设定和协商机制非常基础。费率不是真正的被协商出来的。最低费率是Gavin在不到一年前决定的。当时比特币的价格比现在要低得多。因为这一数值是固定在软件中的，它们不是依美元而定，而是依比特币而定。所以比特币系统在没有良好的理由的情况下，交易成本变高了。Gavin正在研究怎么对那个机制做出改变。 节点将可以观察到广播到系统上的交易，之后他们会看看交易要花多少时间。所以他们会说“如果你想要你的交易在三个区块之内就被处理，你就得付这么多的交易费。”这个想法是矿工可以根据自己的意愿设定交易费。我希望的是，如果其他事情也一切顺利的话，交易费将明显的降低。 当我在2011年开始使用比特币的时候，我的比特币软件花了一天的时间来下载从2009年起源开始到2011年的所有比特币交易记录。到了2013年，如果客户端连续几天没有开启运行的话，它每次启动就得花几个小时来赶上最近几天的交易记录的进度。这个问题会不会在未来随着网络日益繁忙而变得越来越严重？ 终端用户不再需要运行这个软件（也就是那个会把整个区块链文件下载下来的软件）了。我们一直都在做的事情之一，就是让用户们不再使用Bitcoin-Qt，也就是你用的那个（下载整个区块链文件的）软件，而改用其他像Multibit这样的客户端。Multibit将可以在几秒钟之内和区块链完成同步。（搞定上面那个事情）曾经是个大麻烦。如果你有一台一直都在运行着并连接到互联网的计算机，那么你可以通过运行（那个完整版的比特币客户端）软件来帮助整个系统的运行，但如果你只想使用它，那么你就可以选择使用这种更轻量级的软件。（译者写了个迁徙的教程，链接见此） 轻量的程度也有所不同，在2011年的时候，可选项只有Bitcoin-Qt或者网络钱包。从那以后，我们开发了一些中本聪（比特币的创造者）在他的原始论文里面描述的东西。相较于Bitcoin-Qt，它使用了一个相对稍弱的信任模型。在SPV（译者注：简化支付验证）模型中，通过像Multibit和Hive这样的客户端，它仍然扫描整个区块链，并且它假设“拥有大部分矿工的那条区块链就是正确的那条”。而不是验证所有的内容，它只是相信大部分的矿工都是诚实的。它仍然是P2P点对点的。不存在一个告诉你该做什么或者你的结余是多少或者其他东西的中央服务器。只要大部分矿工是诚实的，那么它就能顺利运作。 基本上来说，一个SPV模型拥有一个清单，清单列着的是已经知道是存在于几个月前的最佳区块链上的区块，并随后就只下载区块的一小部分。它下载区块的头部信息，并接着下载相关的交易信息。它连接到一个随机的（在比特币网络上的）节点。SPV客户端并不做出直接的查询。取而代之的是它会上传一个叫做有噪音Bloom过滤器（译者注：Bloom过滤器是以在1970年发明了它的Burton Howard Bloom先生命名的，更多内容请看此链接）的东西，这是个钱包（也就是SPV客户端）需要的看起来像乱码的东西。节点发回一些区块链的子集。SPV客户端会做一些数学上的防伪检查以确保这些东西不是节点伪造的。 所以如果普通用户开始使用SPV客户端而不是完全版的比特币客户端，那对比特币网络的架构会有什么影响呢？ 老实讲，我们还没有很好的度量标准。现在网络上有成千上万个的节点。但所发生的事情是，随着时间的推移，网络结构正在改变。节点的组成上来看，在家里运行的临时节点逐渐减少，而运行在数据中心的长期节点日益增加。 现在租用服务器是非常廉价的。虚拟化技术使得它变得很便宜。所以对于有工作需要运行自有服务器的个人来讲，在服务器上面运行一个比特币节点是完全可行的。完整节点的确会给你带来更好的安全性。举个例子，如果你在运营着一家线上商店，运行一个完整节点是很有意义的。这真的很便宜，反正你的计算机不管怎么样都是要运行着的。 从我们最喜欢的老牌网站到最新近的移动应用，我们日常使用的很多创新技术都要归功于其背后的技术性很强的协议们的存在。终端用户对于这些协议的了解程度，不需要比司机对汽车引擎的工作原理了解的更多。然而，政策制定者们为了推动免许可的分布式创新——也就是由很多独立的个人和创业公司所发起的创新——需要去理解这些协议的重要性。举个例子，超文本传输协议（HTTP）是用来让浏览器可以和网站服务器进行“对话”的——只要服务器实现了这个协议，它就能向任何一个浏览器提供创新的内容或者服务。HTTP本身是建立在许多其他较低层次的协议之上的，比如说DNS和TCP/IP协议。从历史上来看，协议要不是出自研究项目，要不就是出自个人或者小群体。在关于比特币的争论中，理解比特币有潜力成为一个可以开启许多新的创新的协议这一情况，是很重要的。 比特币的核心是一个根本性的创新：一个分布式的公共总账。从会计上来讲，总帐是一本你一旦做出编辑就不能再修改的书。如果你犯了个错，唯一的弥补方法就是在总账上再添加一笔用以撤销那个错误的交易。我们从会计欺诈中可以知道，当有人想出一些法子，使得他们可以不再总帐上做出记录的同时完成交易，或者在时候篡改总账记录（这也是为何Quickbooks 不是真正的属于会计系统）。比特币的总账被叫做“区块链”，区块链有很多份的拷贝并且广泛的分布在世界各地，同时还联合了相当够分量的数学知识，以保证一笔交易一旦被收录到区块链中就没有办法被修改了。当今世界上还没有其他的被广泛使用的协议达到了这样的效果：通过比特币，任何人都可以作出一个声明（一笔交易）并把它记录在一本全世界每一个人都可以看到的且不可修改的总账里面。 为何这个很重要？因为事实证明，可以记录在比特币总账的交易，内置了很多的以脚本语言的形式表现出来的表达能力。这使得某些类型的合约可以建立在比特币之上，从存款到中介再一直到分布式的股票交易。比如说，有一个叫做“色彩币”的提议，它允许额外的数据被附着在比特币之上，并可以在之后的所有交易中都保持两者的关联。举个例子，当区块链成为一间公司的股票份额所有权的完全分布式的公共总账的时候，那些数据就可以代表那家公司的股票的份额（这可能用于取代仍然被大部分创业公司所使用的物理证明或者独立的托管服务）。因为脚本语言的存在，这本总账是事实上智能的，并且一旦股票份额以那种方式被呈现，构建自动化版本的衍生品合约也就变得可能。 这只是比特币作为一种协议可以在金融服务业开启的创新的一些例子。除此之外，比特币协议还有潜力可以以一种全球分布式的方式解决其他的问题，比如说如何分配和管理唯一的名字（参见Namecoin计划）。随着各种机构开始考虑对比特币的监管，在对消费者的保护以及对（有组织的）犯罪的执法，和维护比特币协议成为一种根本性的创新推动者的潜力之间取得一个平衡，是非常重要的。 说到开源协议，比特币的独特之处之一在于它的协议极难做出调整。不像其他的协议，特性可以在一瞬间就完成增加、修改、或者废弃的动作，在比特币的世界里，就算是最轻微的改动也需要整个比特币网络中的绝大多数同时合作。原因很简单：比特币世界，并且只在比特币世界，要求完全的共识。在像HTML和CSS这样的因特网协议里，如果一个网页浏览器错误的解析了一些样式元素，能发生的最糟糕的情况也就是页面渲染不正确。而在比特币这，单单一笔交易被错误的判断成有效或者无效就会让整个块失效，并可能像2013年3月的那次那样，引起整个网络的一分为二。所以，中本聪在2008年做出的绝大多数决策我们都坚持着。尽管中本聪的选择绝对不是完美的，但幸运的是他正确的次数经常比错误要多；事实上，有几个实例，因为中本聪的选择我们获得了更好的结果，而更好结果的原因可能中本聪自己都没想到过。 比特币地址是公钥的哈希值 比特币有有趣的方面之一（对很多人来说可能最开始都有点迷惑），是私钥和比特币地址直接的精准的关系。你把交易发送到一个“比特币地址”，并且声明这笔花出去的交易需要一个相对应的“私钥”的签名。但这两个值之间的关系是怎么样的呢？在一个普通的公钥签名系统里面，步骤如下： 有一个产生密钥对的算法，密钥对由一把公钥和一把私钥所组成，这样私钥可以用于为消息生成签名，公钥可以用于验证那个签名。这样的意义是什么？一般来讲，私钥的持有着希望证明他们亲自写出了或者授权了一条特定的消息。如果除了私钥持有着之外的某个人想要制造一个签名，那么和相对应的公钥的验证就会失败。如果消息在传输过程中被修改，验证同样也会失败。人们可以看到这个机制可以如何的在像比特币这样的货币中被使用：每个人公开他们的公钥，从A发送到B需要A用他的私钥签名一条包含了B的公钥的消息。自此，协议可以推断A想要发送一笔钱给B。 然而，比特币是更加复杂的。比特币的地址不是公钥，而是公钥的哈希值。哈希是一个函数，它可以把任何东西都做输入，并产生一个固定长度的输出，并且此流程基本上不能被反转过来。也就是说，给出一条消息M，计算M的哈希值（hash(M)）是很容易的，但给出hash(M)想要找到M却是直到世界毁灭也不大能完成的事情。比特币的私钥和地址的关系如下： 所以交易是如何工作的呢？除了除了关于交易本身的明显信息以外，一笔比特币交易包括了两个东西：花费者的公钥、以及用花费者的私钥做出的签名。任何一个验证这笔交易的人都需要检查：（1）这个公钥的哈希值是花费者的地址；（2）签名可以用公钥验证通过。把它们放到一起，这些就是交易是由相对应与花费者的地址的私钥的拥有者自己（或者授权他人）进行的。 这点的意义平凡到让人惊讶：在比特币使用的椭圆曲线数字签名算法加密系统里面，一个公钥有512位长度，意味着它需要接近100个字符来呈现。举个例子，下面是一个公钥： 04b52fd5a616a8f08ccad58469102f86fc7891e5aa4262ab8d43e41767c17d45b 80850044a62af51783609176daf02fc46221057a8de11ee6ae8743065b27a4b5e 与此同时，它对应的十六进制形式的比特币地址如下： 4b463093e6fc3135a4de2ff577c4b658198777a9 人们更加熟悉的base58编码形式的是： 1obodiqhAZ3GD9onBXRZ9v7hshkuBreCu 然而，在现实里，。最后发现，有一种以更紧凑的形式编码公钥的方法，只需要257个字节（译者注：这里好像有点问题，应当是257位，参见此文http://618.io/blog/2013/07/30/bitcoin-basic/）： 03c5c9833d00bed3211a5f3733316ecf6ebc407806d70caa14862f1e2e8c2f852d 如果我们决定把它变成base58编码的形式： 15sqRCowBDTfyuxPQD3ba8sN3wBB8MwGbo6gsBEGeKmUbNQADGh 比我们如今使用的地址也没长多少。所以中本聪的选择只是带来了不必要的复杂度和浪费吗？最后证明，答案是否定的。有另外一个非常好的理由去使用这个“公钥的哈希值”的地址结构：量子加密技术。量子计算机可以破解椭圆曲线数字签名算法（也就是说，给定一个公钥，量子计算机可以相当快速的找到对应的私钥），但它们不能相类似的逆转哈希算法（或者说他们可以，但是将需要花掉280个步骤来完成一个比特币地址的破解，这仍然是相当不可行的）。因此，如果你的比特币资金存放在一个你没有支出过的地址里（这意味着公钥是没有公开的），它们在量子计算机面前也就是安全的，至少在你把它们花掉之前。有理论上的途径可以让比特币完全免于量子计算机的威胁，但一个地址只是一个公钥的哈希值的事实，意味着一旦量子计算机真的出现了，在我们全面切换之前攻击者可以造成的损失要小得多。 2100万总币数的限制 比特币有争议的属性之一就是它的固定的供应量。当前每10分钟又25个新的比特币被生产出来，并且这一数字每4年减半。总的来讲，不会有超过2100万个比特币的存在。另一方面，每个比特币可以被划分成1亿份（每份叫做1“聪”），如果一美分都足够买辆车的话，用美元来交易就麻烦重重了，但比特币就算升值到和上面假设的美元的状况，也不会遇到那样的问题。因此，总之，将永远存在的货币单位的总数字是2,100,000,000,000,000，也就是2100万亿，或者说250.899。在选择这个数值的方面，中本聪比大多数人意识到的要幸运的多或者说聪明的多。首先，这个数字远小于264-1，这是一台计算机里面可以以标准整数形式存放的最大整数，超过那个值的话，数值将像里程表那样归零。 其次，然而，还有一个总“聪”数要设法低于的更小的阈值：可以用浮点的格式表示的可能的最大整数。整数不是计算机可以存储的唯一一种数字；为了处理小数，计算机使用一种做浮点表示法的格式。浮点表示法本质上就是一个科学记数法的二进制版本。举个例子，下面是一个在你学习物理学的时候会遇到的值： 地球的质量: 5.972 * 1024 kg 太阳的质量: 1.989 * 1030 kg 光速: 2.998 * 108 m/s 一光年: 9.460 * 1015 m 质子的质量: 1.672 * 10-27 kg 普朗克长度: 1.616 * 10-35 m 我们可以注意到，科学记数法是如何使得你可以在合理的精度下表示所有的这些数值，尽管它们的大小相差极大。浮点表示法本质上就是二进制的科学记数法；当你存储数字9.625的时候，你的计算机存放的是“1.001101 * 1011”（或者说，它存放的是01000000 00100011 01000000 00000000 00000000 00000000 00000000 00000000，这是高精度序列形式的同样一回事）。在这个高精度形式中，系数（也就是不是指数的那部分）有52位（52bits）。这意味着高精度（更加精确的说法是“双精度”）浮点数足以存贮高达253的数字，但不能再高了，如果超过了，你就得开始砍掉末尾的数字。比特币的250.9这一以指数形式表现的总“聪”数，刚好低于这个最大值。 如果我们有了整数，我们为什么还要关心浮点值呢？因为更多的高阶编程语言（比如说Javascript）并不开放低阶的“浮点”和“整数表示法”，而只给程序员提供“数”的概念 – 当然以浮点的形式提供。如果中本聪当时选择了2亿1千万而不是2100万这个值的话，用很多语言里比特币编程就会比现在要麻烦得多了。 注意，Stefan Thomas不幸的在他写BitcoinJS的时候没有及时留意到这个，以至于那个库使用了一个专门的‘大数big number’对象，而不是一个普通数来存储教程输出值；我自己分叉的的BitcoinJS（同时还加入了其他的改进）使用了普通数。 选择正确的椭圆曲线 椭圆曲线加密算法不是一个单独的标准化的加密 消息的方法；事实上有许多不同的“曲线”可供选择。要想理解不同的“曲线”是什么，首先对椭圆曲线加密算法背后的数学原理有一个基本的了解是很有帮助的。总的来讲，一条椭圆曲线是由等式y2 = x3 + ax + b（a和b都是曲线的参数）上的一系列的点（x,y）所组成。 椭圆曲线加密算法依赖于叫做“点加”和“点乘”的在曲线上的运算。 简单讲，想要把P和Q两点相加，就在两点之间画条线，找到这条线和曲线相交的第三个点，然后从那个点话垂直线以得到你的答案。然而，这些曲线有个弱点：它们是不精确的。如果你进行了多次的点加，浮点四舍五入带来的差错就会慢慢的累积，并最终导致结果成为一个没有意义的噪音。因此，椭圆曲线加密算法用了一条修改了两个地方的椭圆曲线。首先，等式现在是 y2 = x3 + ax + b + kp，k可以使任何整数而p是大的素数（除了a和b的曲线参数）。其次，x和y必须是整数。尽管最后出来的结果几乎不是一条“曲线”，但也在数学上够用了，并且限制在整数避免了四舍五入带来的偏差。 有许多不同的曲线参数可以被使用；SEC2文档就提供了一个标准的。然而，一般而言，曲线会被分成两类：“伪随机”曲线以及Koblitz曲线。在一条伪随机曲线里，参数a和b是从某个“种子”通过一个特定的算法（本质上是哈希运算）来选择。对于secp256r1（这是标准256位伪随机曲线）来说，它的“种子”是c49d360886e704936a6678e1139d26b7819f7e90，产生的参数是： p = 115792089210356248762697446949407573530086143415290314195533631308867097853951 a = 115792089210356248762697446949407573530086143415290314195533631308867097853948 b = 41058363725152142129326129780047268409114441015993725554835256314039467401291 一个显眼的疑问：这个种子是怎么来的？为何这个种子不是其他某个看起来更加单纯的数字，比如说15？最近揭露的关于美国国家安全局颠覆加密标准的消息中，一个很重要的点就是说这个种子是以某种方式精心选择的，为了以某种只有国安局知道的方法来弱化这条曲线。谢天谢地，回旋余地不是无限的。因为哈希函数的特性，国安局不能先找到一条“弱”曲线然后再去确定种子；唯一的攻击途径是尝试不同的种子，直到最后有一个种子产生了一条“弱”曲线。如果国安局知道知道一个只能影响一条特定曲线的椭圆曲线的漏洞，那么伪随机数参数的产生流程将阻止他们把那个漏洞标准化推广到其他曲线。然而，如果他们发现了一个通用的漏洞，那么那个流程也就不能提供保护了。我们都知道，c49d360886e704936a6678e1139d26b7819f7e90有可能是美国国家标准技术局尝试过的第10亿个种子。 幸运的是，比特币使用的不是伪随机曲线；比特币使用了Koblitz曲线。比特币的secp256k1的参数如下： p = 115792089237316195423570985008687907853269984665640564039457584007908834671663 a = 0 b = 7 就是这样。并且甚至p都是很容易得出来的；它只是2256 – 232 – 977（公平的说，p和a在secp256r1里面也是相当简单的；它的问题出在b）。这些参数的简约，使得国安局和国家标准技术局没有精心创造一条邪恶曲线的余地。并且甚至0、7、还有977这些数值的采用都是基于安全和效率的考虑而采用的。当Dan Brown，他是高效密码学组标准的现任主席，被问及此事时，他回复说：“我不知道比特币正在使用secp256k1。确实，我对于有人会采用secp256k1而不是secp256r1感到惊讶。”如果secp256r1是事实上的被破解了，那么因为比特币是为数不多的几个采用secp256k1而不是secp256r1的程序，比特币真的是躲过了一颗子弹。 之前写的两篇文章还没有触及比特币的真正意义——也就是“媒介即讯息”的意义上，比特币作为一种新的“环境”的意义。 之前提到比特币的通缩特性、防伪特性等等，这也只不过是在说，它比之前的货币更好。但真正重要的并不是这些能够以同样的标尺衡量的特性，而是它对旧媒介或者说旧环境的颠覆——汽车不仅仅是更快的马车，而且还要整个重构所谓“交通”的环境，改写“出行”的意义。 那么比特币的颠覆性在哪里呢？ 有人说比特币的头号特性是匿名性，这种理解和把互联网的特性理解为匿名性一样是错误的。事实恰恰相反，比特币能够最大程度地支持完全公开透明的交易。其匿名性只是体现在，每个人都可以开设无数个地址用于收款，而每一个地址只是一串无意义的字符。但是，每一个地址之间的每一笔交易，都是公开的，从比特币上线以来的每一笔交易，统统都保存在每一个比特币使用者的钱包中，每一个比特币从诞生起的每一次流转都被记录在案，事实上所谓的比特币实质上就是这一公开的记账系统。 那么只要知道交易链条中的某一个环节究竟是谁，而这个人又愿意说出他的交易对象是谁，那么这样顺藤摸瓜，我们有可能把这个币从诞生以来的每一个拥有者都追查出来。而纸币根本没有这种功能，在这个意义上，纸币才是匿名的货币，它的交易链条不是公开透明的，也难以追索钱的流向。 例如壹基金开通的雅安地震比特币捐款渠道，我们可以在网上看到他的这个账户的每一笔进账和出账，我现在看到它总共收入235个币，除非比特币的数学体系整个崩溃，否则无人可以造假。就现在而言，比特币捐款需要找人兑换成人民币才能支援给灾民，但是如果受惠者也都开通了比特币账号，那么这个账户的每一笔出账究竟送到谁的手里，也都将完全公开透明，如果我愿意公开我所拥有的比特币账户，那么一旦你宣称已经把捐款送到了我的账户上，那么这件事情一定是所有人都能看到的，几时几分给谁汇了几块钱，一目了然，无人可以作假。不需要第三方的监管机构来时刻观察，所有人都可以观察，只要你愿意宣称公开透明，那就一定能够公开透明。 基于比特币的特性，至少是大部分现存的审计和监管的工作，都不再必要了，财务的信用不再需要一个特权的机构来保护，而是由一个开放的交往纽带来保障。 的确，比特币超越了国家的监管，因此在现阶段，它似乎经常被用于地下交易。然而比特币逃离的只是国家或任何单一的权力机构的监管，但它最终将把监管置于光天化日之下。之所以比特币能够用来洗钱，并不是由于比特币的匿名性，而是由于纸币的匿名性——因为用纸币和比特币相互兑换的环节中，纸币的提供者并不在乎比特币的来源是谁。被洗钱的并不是比特币而是纸币。然而，如果人人都使用比特币，比特币本身是难以洗钱的，至少不会比纸币更容易。 归根结底，比特币不是逃脱了监管，而只是逃脱了国家的监管，但在每一个流通的小圈子中，比特币的流向受到每一个参与者的监督，每一个人或机构想要在公众面前取得信誉，不需要仰仗国家或银行的担保，不需要服从于某个上级的管理，而只需要自己开诚布公就足够了。比特币用P2P的网络式监管取代了自上而下的线性监管。 同时，比特币的发行也完全绕开了国家。许多质疑比特币的人提到的第一点往往就是比特币缺乏国家权威的保障。的确如此，但是，我们究竟期待国家给予什么保障呢？国家首先能够保障的是可以不断印钞票，可以随时“刺激消费”，逼迫你把钱花出去保障钱总是在贬值。但这种保障究竟保障的是什么呢？他保障的是企业家和金融家，那些富人们维持着极高的资金周转速度，他们即便手持大量现金，也仍然会大量贷款，就像苹果公司正在做的那样，即便有那么高的现金储备，他也还是不惧怕货币贬值，他的贷款和涨价的产品将会抵消货币贬值造成的损失。简而言之，货币贬值的保障保障的是那些引领着货币流动的人，但普通的老百姓和工薪族呢？他们的资金周转要慢得多，现在收入的钱很可能需要为十几年后的养儿或防老作准备，即便健全的社会保障部分消解了这些未雨绸缪的筹划，普通人也总是难以像大鳄们那样驾驭资金的流转。一旦货币贬值，存款和工资大幅缩水的时候，工薪阶层又能指望谁来保护自己呢？ 是的，国家能够保障货币的法律地位，也就是说，再怎么贬值，货币都是法定有效的。这意味着什么呢？当发生津巴布韦或金圆券那样剧烈贬值的情况时，它们也仍然是法定有效的货币，即便你上午领到的工资到了下午就将跌去十倍，你也不得不接受它们，因为法律保障了它们的有效性。善良的企业家也许会转而使用外汇或金银来支付工资，但如果他们仍然坚持给你金圆券，那你也无话可说，因为这是国家保障的法定货币。 一个最高的中央权力机构的存在让人有某种安全感，但它究竟提供了多少保护，其中有多少未必需要一个中央集权的机构就能够组织起来，又有多少只是单纯的迷信呢？ 我们的确需要警察局，需要消防队，需要军队和红十字会。但这些机构的背后必定要有一个中央集权的“国家”来支撑吗？像古希腊那样，不需要大一统的政权，依靠分散的小城邦进行自治行不行呢？当然，你会说此一时彼一时也，希腊社会的交往关系和现代人非常不同了，但如果说网络时代的社会交往关系又将与我们现在大为不同呢？国家的金字塔结构一定是永存的吗？ 我一点也没有反党反社会主义，恰恰相反，共产主义的终极理想就是消灭国家。无论马克思的理想是否空幻，他至少认识到了国家只是一个历史性的事物，它并非古已有之，也不会亘古永存。 20世纪的历史似乎证明了完全自由放任主义的市场经济是行不通的，然而这是否意味着市场一定需要由一个中央集权的机构来调控呢？由于依赖中央银行的货币体系的缘故，似乎市场的调控者不得不位于中央，然而这一由央行和各级银行和金融机构形成的金字塔式的货币体系一旦被打破呢？ 我们仍然迷信着中心化的神话，我们相信有一群经济学家日理万机地监视着市场并且会适时地采取合理的措施，这就好比古代人相信没有皇帝日理万机就无法保障自家田地的收成那样。的确我们需要“日理万机”，但这未必一定要仰仗一个英明神武的皇帝或一小撮聪明绝顶的经济学家。就像开源软件的运行模式那样，只需要一些较弱的维护者，他们无法暗箱操作或垄断一切，其地位随时可能被其它分支所取代，至于大量的维护、修补和创造性的工作都由整个社区来分担。 政治空间的结构与传播媒介的结构是相应的，口头传统倾向于维系松散的部落组织，文书传统倾向于中央集权的文官制度，印刷术加强了民主，而广播又倾向于独裁……网络时代也将促进其特有的空间结构，即网络。一种去中心化的、互相链接的组织形式将更有优势。 当然，国家仍将存在，但它作为权力中心的管控地位将会淡化，剩下的更多是其文化和历史的意义。比特币将是这种网络社会的里程碑之一，它对资本主义社会的核心——“资本”的运转方式发起了变革，在某种意义上说，比特币使得这种新的政治经济学结构——我们可以称之为“社会主义”——成为可能。社会主义不信任资本家和垄断者，而相信自下而上的、广泛而自由的社群的力量。 比特币出问题了。并且不是浅层的，而是根本性的在核心协议层上的麻烦。我们在这里不是在谈论一个简单的缓冲溢出，或者一个可以被轻松修补上的糟糕API设计；相反，这个问题是整个比特币工作原理所固有的。所有其他的基于比特币理念的加密货币或者方案，包括Litecoin、Namecoin、以及所有灵感来自比特币的其他货币，都出了问题。 特别是在一份我们在arXiv上发表的论文中，Ittaly Eyal和我概述了一种攻击方式，通过这种攻击，少数的矿工就可以获得超出他们应得份额的收入，并且数字不断增长直到他们成了多数。当触及这一时间点时，比特币的价值主张就崩溃了：该货币被单个实体所控制；它不再去中心化；掌握控制权的实体可以决定谁能参与到挖矿中来，以及哪比交易可以被处理，并甚至能够随意回滚交易。这样的雪球般越滚越大的崩溃并不需要一个居心不良的邦德式的坏蛋来启动；它可以作为人们尝试通过挖矿的努力挣得更多的一点钱的共同努力的结果而发生。 传统观点长期以来认为只要多数矿工是诚实的（这里说的诚实，我们是指他们尽职的遵守化名中本聪的那位提出来的协议。），比特币就能安全的抵抗成群的相互勾结的矿工的威胁。我们的论文证明那一说法是错误的。我们证明了，在当下，任何采用我们的攻击方法的节点群组都将成功挣得比他们应得份额更多的收入。我们还证明了一条新的可以让诚实的大多数的声明无效的底线：在最好的情况下，至少要有2/3的参与者节点是诚实的，才能成功抵抗我们的攻击。但取得这一2/3的底线在实践上是很困难的。我们描述了一个容易部署的对协议的实用补丁，只要3/4的矿工是诚实的，就可以抵御攻击。 我们需要比特币社区的帮助以部署这一补丁以使得比特币生态系统能够变得更加强壮，至少可以低于算力低于全网算力25%这一阈值的攻击。但是，就算部署了我们的补丁，也还有一个问题：现在有矿池占据着超过25%的全网算力，并且，在过去曾经有矿池的算力占比超过了全网算力的33%。我们需要比特币社区意识到并共同努力以保证没有矿池能够超过那个阈值。整个系统会进入一个易受攻击的状态的可能性，将阻碍比特币更广泛的为人们所接受。 如果想要一份对这种攻击手法的精确的全解析，你可以直接阅读这篇研究论文，尽管它可能有点洗练且枯燥无味。在这篇文章的余下部分，我们将为非铁杆参与者们勾勒出这个攻击手法，读完全文，任何人都应当能明白我们的攻击手法背后的直觉，添置装备以通过挖矿获得更高的收入，并获取掠夺这种货币所需要的工具。为了达到这一效果，我们需要一点点的关于比特币工作原理的背景知识。如果你对比特币挖矿熟悉，那么你可以跳过下一段对攻击原理的描述。如果你是一名对技术不感兴趣的比特币用户，你可以直接跳过到最后的关于影响的章节。 区块链 比特币成功背后的核心概念是一个用以维持一本全球性的总账的去中心化协议，它被叫做区块链。区块链记录着比特币地址之间的交易，追踪着每一个比特币转手的举动。这样的追踪确保了没有人可以双花（double-spend）一个币，因为总账使得一名用户是否发送出了比他挣得的更多的比特币变得太明显。比特币追踪的特别方式，也使得交易记录不可被变更；一旦一笔比特币交易被处理并收录进了区块链，攻击者就很难逆转那笔交易了，所以商户可以在有信心交易不会被逆转的情况下发出货物。 协议通过一个叫做挖矿的流程来实现。简单讲，总账是由一条有序的区块所组成，每一个区块记录着一系列的交易。每个区块都包含了一个密码谜题，这是一个类似于CAPTCHA的难以计算的挑战。矿工自组织成一个松散的分布式网络，他们都同时在尝试在总账上添加一个新的块。为了做到这个，他们需要找到一个密码谜题的答案，谜题是由从总账初始到新区块被添加上去这段时间的内容所决定的。解决密码谜题是个艰难的工作；电脑必须尝试不同的值，并查看他们是否解决了新区块带来的密码谜题。有的人使用GPU来加速这一流程，同时还有其他人投资在了定制ASIC设备上以解决比特币密码谜题。 当然，这一流程不是义务的，因为解决这些密码谜题耗费电力并需要冷却。为了让比特币变得切实可行，矿工们因为他们的辛勤工作而得到补偿。比特币矿工们通过两个机制获得补偿：他们拿走他们贡献给区块链的新区块里面记录着的交易的交易费，同时他们还拿走一整笔币。这一整笔的币就是新创造的比特币，新创造的币的数量基于一个随时间变化的公式。因此，“挖矿”就类似于挖金矿了——每隔一段时间，一名矿工就挖到了一个金块。密码谜题的难度是自动调整的以保证差不多每10分钟就有一个新区块添加到总账上，这保证了整个系统的比特币产出速率是可以被预测的，这也就阻止了通胀并且使得货币的供应更具可预测性。 密码谜题是如此的高难度所带来的好处在于，攻击者想要修改总账变得很困难。比如说，有人想要从比特币商户那里买点东西，商家发货了，然后改变那个区块，这个任务非常的困难：他们需要为那个区块以及随后的每一个区块找到替代性的答案。难度在于，矿工的主体都会在总账的尾端上努力工作添加新的区块，所以一个攻击者在有限的资源情况下，不能指望会为所有的之前的区块找到替代性的答案并追赶上其他的矿工。 现在的矿工们自组织成一个个叫做矿池的小组。一个矿池通常由一批共同合作的节点组成，他们不论什么时候发现新区块都把收入拿出来共享。矿池有点类似于旅馆的共享小费罐，一名矿工撞大运发现了一个密码谜题的答案并拿到一些收入，类似于一名为一大桌高额消费了的顾客提供服务的侍者。从任何给定矿工的角度来看，挖到矿这件事发生的频率相对不是那么频繁，共享这一流程则可以让矿工对于挖矿收入有更好的预测。 攻击 诚实的比特币协议假设所有的矿工采取的是一个良性的策略，他们快速并如实的分享挖到的每一个区块。直到现在，每个人都假设这是占优策略；没有其他的已知策略能够为矿工带来更高的收入。 我们的文章证明存在着一个叫做“自私挖矿法Selfish-Mine”的替代性测量，可以使得矿池在伤害整个系统的风险之下获得额外的收入。在自私挖矿法中，矿工把他们的区块发现藏在他们自己的矿池中而不公开，并且在恰当的时候把隐藏着的区块向诚实的矿工们公开，以此迫使诚实矿工们的资源被浪费在最后不是区块链的一部分的区块上面。 以下是它在实践中的实现方法。自私的矿工们就如普通矿工们一样的开始挖矿，工作以找到一个可以链到区块链末端的新区块。就像其他的矿工，他们偶尔会发现一个新的区块并领先于其他的诚实矿工。诚实的矿工会立刻公布这个新的区块并使得其他诚实矿工转到最新确立的区块链末端进行挖矿，而自私的矿工把这个区块藏了起来。 从此开始，有两个事情可以发生。自私矿工可能再次走运，发现另一个区块而增加他们的领先程度。他们将领先其他的诚实矿工两个区块。他们继续把新发现的区块藏起来，并继续工作以扩大他们的领先优势。最后，诚实矿工快要赶上自私矿工的进度的时候，自私矿池公布了它的更长的区块链。结果就是所有的诚实矿工的工作都被抛弃了，并且自私矿工从他们之前的隐秘区块链中得到了收入。 关于收入的分析从这里开始变得技术性了，研究我们在论文中提出的算法和状态机是唯一的公正的办法。但最后的结果是，总的来讲自私矿池通过他们在适当时机的公开（之前隐藏的区块），可以让诚实矿池做过的工作无效化。 攻击的成功率，以及它所能产生的额外收入的数量，取决于自私矿池的规模大小。如果该矿池算力占比低于某一个阈值，它就不会成功。但在当前的实现（自私矿工可以即刻获得利润）之下，这样的阈值并不存在。我们提出的补丁如果被全局性的采用，可以把阈值提高到25%。并且，尽管可能还会有其他的补丁，但没有一个补丁可以把阈值提高到33%以上。也就是说至少要有2/3的比特币矿工是诚实的。以上所有的三个发现（0%、25%、33%）都比之前认为的可以保卫这种货币的50%要低得多。 影响 对比特币系统而言，自私挖矿测量有着极其深刻的影响： 自私矿池的成员将比诚实的参与者拿到更多的收入：这意味着理性的利己的矿工（他们通常都在设备上投入了大量的金钱），将会想要加入自私矿工而不是继续遵守诚实策略。 一旦开始并成功，自私矿池的规模将增大：没有任何机制可以对自私矿池施加压力以拆散他们。 自私挖矿对比特币社区是有害的：自私矿工们把每个人都收入都拉低了。自私矿工可以发动攻击，以及一个自私矿池的规模将增长知道它控制了这一货币的事实，对于人们（比如说被比特币去中心化的特性所吸引的Winklevoss兄弟）来说具有相当的威慑力。 这一攻击在当前对于任何规模的矿池都是可行的：任何人都可以在现在成功的发动这样的攻击，并且赚得超过他们应得的收入。 在最好的情况下，比特币也要求至少2/3的矿工是诚实的：之前认为只要多数人是诚实的，比特币生态系统就是安全的。我们的分析说明那一想法是错误的。一个拥有超过全网算力33%的自私矿池，将总是可以挣得超过诚实矿工的收入。 我们提出了一个可用的补丁，只要自私矿池的算力低于全网算力的25%，它就可以保护比特币网络抵御自私挖矿的攻击：这一补丁很容易部署。比特币社区采用它将是个不错的主意。 现在存在着几个可以设想成功发动自私挖矿攻击的矿池：在当下，任何矿池都课程发起成功的攻击。用上我们的补丁之后，之后算力超过25%的矿池可以发动攻击，但现在已经存在着这个规模的矿池了。并且曾经存在过拥有超过33%全网算力的矿池。 FAQ 一些经常被问到的问题： 当一个自私挖矿组织组成的时候，会发生什么？ 一旦出现了一群自私矿工，理性的矿工将更愿意加入他们以攫取更好的收入。并且他们的收入将随着组织规模的变大而变得更高。这使得攻击者可以快速的获得多数的算力，而在那个时候比特币去中心化的特性就崩溃了，因为攻击者获得了对所有交易的控制权。 单个矿池控制这一货币的时候，比特币的价值会归零吗？ 不。这取决于掌握控制权的矿池如何运营这一货币。但在我们看来对比特币能否为人们所接受的最重要的去中心化特性就丢失了。这对比特币生态系统而言一点也不健康。 这会影响X吗？X是另外一种加密货币。 有可能。它影响着每一个从比特币的区块链概念中获得灵感的货币系统。这包括Litecoin、 PPcoin、Novacoin、Namecoin、Primecoin、Terracoin、Worldcoin、以及其他一堆拥有相似的全局总账概念的货币。 这里的核心发现是什么？ 我们是第一个发现比特币协议和激励机制不兼容的。协议可以为自私的人群所玩弄。并且一旦系统脱离了每个人都是诚实的欢乐模式，没有力量可以阻挡一个可以控制这一货币的真正的大型矿池的崛起。 自私挖矿现在正在发生吗？ 我们没办法确定，但我们认为还没有。我们的论文是第一份公开研究替代性挖矿策略的文章。 那两个阈值是什么情况？是不是2/3的节点必须是诚实的？还是说是3/4？为什么这两个阈值之间有差距。 在当下，阈值是不存在的。部署了我们提出的补丁（使用并且容易部署）之后，阈值升到25%；也就是3/4的矿工必须是诚实的。可能有人能提出进一步提高阈值的补丁，但我们已经证明阈值不会超过33%。 我们是否可以分辨自私矿池和其他的矿池？ 不容易。自私矿池可以通过使用一次性的地址来掩饰它的身份。并且尽管自私矿池揭露它之前隐藏的区块的时候，会看起来会有些不同，但分辨谁是真正的第一个发现区块的矿工很困难，因为几乎同时发生的挖到区块将会以不同的顺序抵达主机。 把这一攻击手法公布于众会不会招致什么危险？ 保护这一系统抵御自私挖矿攻击的唯一 途径就是让每个人改变他们当前的实现。所以我们只能通过公布这一潜在的攻击手法来保卫这一系统。我们选择了不自己发动这样的攻击，因为我们关心这一货币的长期可行性。 比特币还可能是一个可行的货币吗？ 可能吧。我们已经证明只要自私矿工的算力低于某一个阈值，他们就不会成功。并且尽管目前这一阈值还不存在（因为不论规模大小的自私挖矿都将立马获得收益），我们已经提出了一个可以把阈值提高到25%的补丁。 作者 Vitalik Buterin原文地址]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>区块链 入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链(Blockchain)深入介绍]]></title>
    <url>%2Farchives%2F01-blockchain-introduction.html</url>
    <content type="text"><![CDATA[一、区块链是什么？区块链是一个公共的分布式总账，任何发生在此区块链网络上的交易会被约定的算法记录到区块链上，且满足以下条件： 存储基于分布式数据库 数据库是区块链的数据载体，区块链是交易的业务逻辑载体 区块链按时间序列化Block，且每个确认块是整个网络数据共识的唯一准则 区块链只对添加有效，对其他操作无效 基于非对称加密的公私钥验证 记账节点要求拜占庭将军问题可解/避免 共识过程(consensus progress)是演化稳定的，即面对一定量的不同节点的矛盾数据不会崩溃 共识过程能够解决double-spending问题令记账（又名矿工）节点 = N，当N 公开且自由访问，则这是一条 公有链 （后面有介绍）当N 半公开仅由某个组织或团体内部使用（例如R3 CEV），外部仅可以（授权）查询，则这是一条联盟链。当N = 1， 则这是一条私有链 （这里有些许争议，如果在一个团体内部看这条链，这条链可能又是“公有的”，这取决于你在不在这个团体内部，不过这不影响它的所有权归属，与传统数据库是类似的） 一、区块链是什么？区块链是一个公共的分布式总账，任何发生在此区块链网络上的交易会被约定的算法记录到区块链上，且满足以下条件： 存储基于分布式数据库 数据库是区块链的数据载体，区块链是交易的业务逻辑载体 区块链按时间序列化Block，且每个确认块是整个网络数据共识的唯一准则 区块链只对添加有效，对其他操作无效 基于非对称加密的公私钥验证 记账节点要求拜占庭将军问题可解/避免 共识过程(consensus progress)是演化稳定的，即面对一定量的不同节点的矛盾数据不会崩溃 共识过程能够解决double-spending问题令记账（又名矿工）节点 = N，当N 公开且自由访问，则这是一条 公有链 （后面有介绍）当N 半公开仅由某个组织或团体内部使用（例如R3 CEV），外部仅可以（授权）查询，则这是一条联盟链。当N = 1， 则这是一条私有链 （这里有些许争议，如果在一个团体内部看这条链，这条链可能又是“公有的”，这取决于你在不在这个团体内部，不过这不影响它的所有权归属，与传统数据库是类似的） 二、历史背景、现状以及前景区块链诞生自中本聪的BTC，自2009年以来，出现了各种个样的类BTC的数字货币，都是基于公有区块链的。数字货币的现状是百花齐放，列出一些常见的：bitcoin、Litecoin。除了货币的应用之外，还有各种衍生应用，如比特股，彩色币，Ripple，Ethereum等等可以用区块链的一些领域可以是： 智能合约 证券交易 电子商务 物联网 社交通讯 文件存储 存在性证明 身份验证 股权众筹 区块链的发展可以类比互联网的发展，有朝一日会在internet上形成一个比如叫做finance-internet的东西，而这个东西就是基于区块链，它的前驱就是bitcoin，传统金融从私有链/联盟链出发（局域网），bitcoin 系列从公有链（广域网）出发，都在往同一种概念上收敛——基于数字资产（Digital Asset）的智能化金融世界。 区块链的进化方式可以是： 区块链1.0 - 围绕数字货币的货币和公证生态 区块链2.0 - 围绕数字资产与智能合约的合约生态 区块链3.0 - 以上面两个为基础的自治社会生态=&gt;DAO/DAC（区块链自治组织/区块链自治公司）=&gt; 区块链社会（区块链+人工智能）。 区块链普及程度图: 三、 分类区块链分公有链(public chains) 和 广义的私有链(private chains)。公有链：是指世界上任何个体或者机构都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可参与其共识过程，记账权完全由公开的共识算法决定，即整个网络是开放的。 广义的私有链又分联盟链（consortium chains）和完全私有链(private chains)。联盟链：顾名思义，一般是指由少数的机构组成联盟节点，联盟之间是有价值传输的，属于协作关系但同时又不能完全信任，典型的场景有跨境支付，票据市场，场外市场等等。一般由PBFT一致性算法改造的共识算法，节点数不会太多，同时要求出块速度快，并且所有节点是需要准入的，也就是通过许可才能访问该联盟链（我们也称联盟链为许可链）。完全私有链：仅仅使用区块链的分布式账本技术进行记账，与其他的分布式存储方案没有太大区别（讲真，如果不是政治任务，别想用区块链替代数据库，吃力不讨好） 四、从技术角度看区块链首先来看基于公有区块链讲解的两张图： 在图2中存在一个中心机构O，所有的节点要参与交易必须通过中心机构O来达成交易。这里的中心机构O扮演了两个身份，一个是维护者的身份，即维护交易账目且正常达成交且真实可靠的，另外一个是特权参与者的身份，即发行货币（资产）的权利。如果我们要去中心化，那么我们应该如何做？ 第一是去掉维护者这个身份，如何去掉它又能保证交易能正常完成且真实可靠呢？首先在区块链上我们只记录交易本身，而不是记录每个人的账户余额，然后大家一起记账，都写到一个账本（区块链）上，并且每个人都保留一份总账副本。这个问题其实分两层，第一层是一个技术问题，并且已经有成熟的解决方案了，就是使用P2P技术（如有名的BT协议），大家都来同步分布式总账本，大家发送交易直接to peer，并且通过公私钥技术来验证peer。第二层是一个确认真是交易的问题，我们通过共识过程(consensus progress)来确认交易的有效性。目前有四种共识过程可以选择：工作量证明（POW）、 （权益证明） POS、 DPOS、 POOL。第二是去掉特权参与者这个身份，如何去掉它又能保证资产的流通呢？这个问题也是一个核心问题，在公有链上，他们可以发行自己的虚拟货币，如bitcoin, litecoin。而在私有链的实现方式里，是将资产直接数字化，可以将对应的物理实体细分所有权发行。在图3中节点A直接发交易给节点D，所有节点一起确认并且验证交易的真实性，更新了公共总账以后，所有人再同步一下最新的总账。这里我们将维护者的身份下放至每一个参与者手中，并且通过加密算法来保证交易真实可信，这里我们不需要对账，我们只需要维护一条总账就可以。 五、从经济学角度看待区块链（本节还没有详细讲） 货币的本质：货币只是一种广泛价值共识，本身不具有价值沉淀。资产与货币的关系：货币描述资产。什么是数字资产：资产数字化，可细分，可交易，价格由供需市场决定，而不是价值中介——货币决定。区块链如何将资产数字化（略）推荐阅读：哈耶克 《货币的非国家化》 另外一个有意思的概念是POS共识提出的币天销毁的概念，这可能是一个非常有意思的经济学概念，推荐阅读 长铗《区块链：从数字货币到信用社会》 六、区块链共识算法共识算法参考《浅谈区块链共识机制与分布式一致性算法》 七、区块链的项目介绍 中国区块链发展现状数据总览 联盟区块链项目介绍]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>区块链 入门</tag>
      </tags>
  </entry>
</search>
